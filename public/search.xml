<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中为什么没有虚字段表来实现方法调用和字段访问的一致性？</title>
    <url>/2023/04/16/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E8%99%9A%E5%AD%97%E6%AE%B5%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #虚方法表 #字段访问 #设计原则</p>
<hr>
<blockquote>
<p>那为什么 Java 不设计一个虚字段表来实现方法调用和字段访问的结果一致呢</p>
</blockquote>
<p>虽然在某些情况下，实现一个虚字段表似乎能让方法调用和字段访问的行为保持一致，但这并不符合 Java 的设计原则。在 Java 中，方法和字段的作用和原理是有所不同的：</p>
<ol>
<li>方法是用于定义对象的行为的，它们可以被子类覆盖以实现不同的行为。这是多态的核心，它允许我们以统一的方式处理不同类型的对象。为了实现多态，Java引入了虚方法表，使得方法调用在运行时可以根据实际对象类型执行相应的方法。</li>
<li>另一方面，字段用于存储对象的状态。通常，我们希望字段在编译时就能确定，以避免意外地改变对象的状态。将字段设置为私有并通过方法（getter和setter）访问，是一种常见的封装实践，以确保字段访问的正确性和安全性。</li>
</ol>
<p>设计一个虚字段表可能会引入额外的复杂性，并使得字段访问的性能受到影响。在Java中，编译时字段访问和运行时方法调用的不同行为是有意为之，以确保代码的可读性、可维护性和执行效率。</p>
<p>总之，Java之所以没有引入虚字段表，是因为它违背了字段和方法的基本设计原则。在处理多态时，我们应该通过方法调用来实现多态行为，而不是直接访问字段。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>虚方法表</tag>
        <tag>字段访问</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中static、final和private方法为什么不是动态绑定</title>
    <url>/2023/04/16/Java%E4%B8%ADstatic%E3%80%81final%E5%92%8Cprivate%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #静态方法 #final方法 #private方法 #动态绑定 #静态绑定</p>
<hr>
<p>在Java中，静态方法、final方法和private方法（隐式final）都不是动态绑定的，而是静态绑定的。以下是对这几种方法为什么不是动态绑定的解释：</p>
<ol>
<li> static方法：</li>
</ol>
<p>静态方法是类级别的方法，它们不依赖于具体的实例，而是与类本身相关。因此，当调用静态方法时，编译器可以在编译时确定要调用哪个类的静态方法。不需要等到运行时去查找实际的实现。所以，静态方法不需要动态绑定，而是采用静态绑定。</p>
<p>举例：假设我们有一个父类<code>Parent</code>和一个子类<code>Child</code>，它们都有一个静态方法<code>staticMethod</code>。当我们调用<code>Parent.staticMethod()</code>或<code>Child.staticMethod()</code>时，我们直接告诉编译器要调用哪个类的静态方法，不需要动态绑定。</p>
<ol start="2">
<li> final方法：</li>
</ol>
<p>final方法是不允许被子类重写的方法。这意味着，当调用一个final方法时，编译器可以确保在编译时确定要调用的具体实现，而无需等到运行时去查找。因此，final方法也采用静态绑定。</p>
<p>举例：假设我们有一个父类<code>Parent</code>，其中有一个final方法<code>finalMethod</code>。如果有一个子类<code>Child</code>继承自<code>Parent</code>，那么<code>Child</code>不能重写<code>finalMethod</code>。因此，当我们调用<code>Parent.finalMethod()</code>或<code>Child.finalMethod()</code>时，编译器已经知道要调用的是<code>Parent</code>类的<code>finalMethod</code>，无需动态绑定。</p>
<ol start="3">
<li> private方法（隐式final）：</li>
</ol>
<p>private方法是类的私有方法，它们不能被子类访问或重写。实际上，它们对子类是不可见的。因此，当调用一个private方法时，编译器可以在编译时确定要调用的具体实现。这使得private方法也采用静态绑定。</p>
<p>举例：假设我们有一个类<code>MyClass</code>，其中有一个private方法<code>privateMethod</code>。当我们调用<code>MyClass.privateMethod()</code>时，编译器已经知道要调用的是<code>MyClass</code>的<code>privateMethod</code>，无需动态绑定。</p>
<p>综上所述，由于静态方法、final方法和private方法在编译时就可以确定具体的实现，它们不需要动态绑定，而是采用静态绑定。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>静态方法</tag>
        <tag>final方法</tag>
        <tag>private方法</tag>
        <tag>动态绑定</tag>
        <tag>静态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>is-like-a关系中向上转型的示例</title>
    <url>/2023/04/16/is-like-a%E5%85%B3%E7%B3%BB%E4%B8%AD%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E7%9A%84%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #向上转型 #is-like-a关系 </p>
<hr>
<p>假设我们有一个基类 Animal 和两个子类 Dog 和 Bird。其中，Dog 类扩展了 Animal 类并添加了一个新方法 <code>bark()</code>，Bird 类也扩展了 Animal 类并添加了一个新方法 <code>fly()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设我们有一个方法 <code>makeAnimalEat</code>，这个方法接受一个 Animal 对象，并调用它的 <code>eat()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeAnimalEat</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    animal.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们不关心传入对象的具体类型，只要它是 Animal 或其子类即可。现在，我们可以创建 Dog 和 Bird 对象，并将它们向上转型为 Animal 类型，传递给 <code>makeAnimalEat</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line"></span><br><span class="line">makeAnimalEat(dog); <span class="comment">// 向上转型为Animal</span></span><br><span class="line">makeAnimalEat(bird); <span class="comment">// 向上转型为Animal</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，向上转型允许我们将Dog和Bird对象视为Animal对象，并通过<code>makeAnimalEat</code>方法调用它们的<code>eat()</code>方法。然而，这也意味着我们不能在<code>makeAnimalEat</code>方法中直接调用Dog的<code>bark()</code>方法或Bird的<code>fly()</code>方法，因为这些方法不属于Animal类的接口。</p>
<p>在某些情况下，我们可能需要在 <code>makeAnimalEat</code> 方法中根据传入对象的确切类型执行一些特定操作。例如，我们希望让 Dog 在吃东西之前先叫一下。为了实现这个功能，我们需要重新确定对象的类型，然后调用相应的扩展方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeAnimalEat</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">        ((Dog) animal).bark();</span><br><span class="line">    &#125;</span><br><span class="line">    animal.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用<code>instanceof</code>操作符检查对象是否为Dog类型，如果是，则向下转型并调用<code>bark()</code>方法。注意，这种类型检查和向下转型的操作会降低代码的灵活性，并可能导致不易维护的代码。但在某些情况下，这种方法可能是必要的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>向上转型</tag>
        <tag>is-like-a关系</tag>
      </tags>
  </entry>
  <entry>
    <title>一条通用准则</title>
    <url>/2023/04/16/%E4%B8%80%E6%9D%A1%E9%80%9A%E7%94%A8%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p>使用继承表达行为的差异，使用属性表达状态的变化。</p>
]]></content>
  </entry>
  <entry>
    <title>为什么不使用接口实现eat方法</title>
    <url>/2023/04/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0eat%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #继承 #接口 </p>
<hr>
<p>在某些情况下，使用接口确实是一个更好的选择，尤其是当我们希望保证类遵循某个特定的约定（比如具有 <code>eat()</code> 方法）时。如果我们认为 Animal 类不需要包含任何默认实现或共享状态（属性），那么使用接口可能是一个更合适的选择。</p>
<p>以下是一个使用接口的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用接口的好处是它可以让我们保证所有实现了 Eatable 接口的类都必须提供 <code>eat()</code> 方法的实现。这使得我们可以在需要 Eatable 对象时，确保它们都具有该方法。</p>
<p>然而，使用接口并不总是更好。在某些情况下，使用继承可能更适合。例如，如果Animal类包含一些共享的状态（属性）和方法实现，那么使用继承将使我们能够更轻松地在子类中复用这些共享代码。此外，我们还可以利用继承在子类中覆盖基类方法，以提供更具体的实现。</p>
<p>总之，在确定是否使用接口或继承时，需要考虑类之间的关系、代码重用、以及预期的扩展性。根据具体情况，我们可能会选择实现接口，或者继承一个基类，或者同时使用这两种方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>继承</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么构造器中的动态绑定方法绑定了子类方法</title>
    <url>/2023/04/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%BB%91%E5%AE%9A%E4%BA%86%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #构造器 #动态绑定 </p>
<hr>
<p>在 Java 中，除了 <code>static</code> 和 <code>final</code> 方法（<code>private</code> 方法也是隐式的 <code>final</code>）以外，其他所有方法都是后期绑定，即动态绑定。这意味着在编译时并不确定要调用哪个方法，而是在运行时根据对象的实际类型来确定要调用哪个方法。</p>
<p>在你提供的示例中，<code>Base</code> 类的构造器中调用了 <code>show()</code> 方法。当我们创建一个 <code>Derived</code> 类的实例时，它首先会调用父类 <code>Base</code> 的构造器。此时，虽然是在父类构造器中调用 <code>show()</code> 方法，但实际创建的对象是 <code>Derived</code> 类型。由于 <code>show()</code> 方法是动态绑定的，因此在运行时，Java 会根据对象的实际类型（<code>Derived</code> 类型）来确定调用哪个方法。因此，此时调用的是 <code>Derived</code> 类中重写的 <code>show()</code> 方法，而不是 <code>Base</code> 类中的 <code>show()</code> 方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>动态绑定</tag>
        <tag>构造器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用继承复用共享代码的例子</title>
    <url>/2023/04/16/%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E5%A4%8D%E7%94%A8%E5%85%B1%E4%BA%AB%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #继承 #代码复用</p>
<hr>
<p>以下是一个使用继承来复用共享代码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Animal</code> 类有两个属性 <code>name</code> 和 <code>age</code>，以及一些共享的方法 <code>eat()</code>、<code>sleep()</code>、<code>getName()</code> 和 <code>getAge()</code>。通过继承 <code>Animal</code> 类，我们可以在 <code>Dog</code> 和 <code>Bird</code> 子类中复用这些共享的代码。</p>
<p>注意，在子类中我们使用<code>super()</code>调用来调用父类的构造方法，这样我们就可以在子类中设置<code>name</code>和<code>age</code>属性。另外，我们可以通过<code>getName()</code>和<code>getAge()</code>方法访问这些属性，从而在子类中实现自定义行为，如<code>bark()</code>和<code>fly()</code>方法。</p>
<p>继承使我们能够在不修改<code>Animal</code>类的情况下轻松地为<code>Dog</code>和<code>Bird</code>类添加新功能，同时保持共享代码的一致性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>代码复用</tag>
      </tags>
  </entry>
  <entry>
    <title>在选择接口实现和继承关系时的考虑因素</title>
    <url>/2023/04/16/%E5%9C%A8%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%97%B6%E7%9A%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #接口 #继承 #设计原则 </p>
<hr>
<blockquote>
<p>所以我们可以说，在选用接口实现还是继承关系上，我们可以通过判断到底是各各类之之间只是行为上相似，还是在不仅仅行为上、状态上也有信息需要共享，是这样么？希望更正或补充，如果表述上有欠缺的。</p>
</blockquote>
<p>是的，您的理解是正确的。在选择使用接口实现还是继承关系时，我们需要根据类之间的关系来判断。以下是一些关键点，可以帮助您决定使用哪种方式：</p>
<ol>
<li>如果类之间存在共享的状态（属性）和行为（方法实现），那么使用继承关系可能更合适。这样可以通过父类来复用这些共享代码，同时保持代码的一致性。</li>
<li>如果类之间仅仅在行为上相似，但没有共享的状态或方法实现，那么使用接口实现更合适。接口可以定义一组共享的行为，强制实现类遵循这些行为，但不强制它们共享任何状态或方法实现。</li>
<li>另外，还要考虑”单一职责原则”和”开闭原则”等设计原则。遵循这些原则可以帮助您创建更加灵活、易于维护的代码。</li>
</ol>
<p>总之，在选择使用接口实现还是继承关系时，关键是了解类之间的关系，以及它们之间需要共享的信息。您可以根据这些信息来决定使用哪种方式，以满足代码的复用、扩展和维护需求。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计原则</tag>
        <tag>继承</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>多态、接口与抽象类的关系与意义</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #接口 #抽象类 #设计</p>
<hr>
<blockquote>
<p>当我们已经有多态这一机制了之后，为什么还有 implements 这一设计呢？直接设计一个最上层的父类然后设计很多需要子类实现的抽象方法不就好了么？如果这样的方式不是多态的目的，那么抽象方法本身存在的意义又是什么呢？能否同时举例说明上述问题？</p>
</blockquote>
<p>多态是一种编程范式，它允许我们使用一个通用的接口引用不同类型的对象，并在运行时动态调用相应的方法。接口和抽象类都是实现多态的方式，但它们有不同的用途和特点。</p>
<ol>
<li> 接口（implements）：</li>
</ol>
<p>接口定义了一组规范，强调了类实现的“能做什么”。接口可以被多个类实现，这样可以实现多重继承的效果。当一个类实现了一个接口时，它承诺实现接口中定义的所有方法。这对于定义一些通用的行为和功能非常有用。接口还允许我们将实现和使用分离，使代码更加灵活和易于维护。</p>
<ol start="2">
<li> 抽象类（extends）：</li>
</ol>
<p>抽象类是一个特殊的类，它不能被实例化，只能被继承。抽象类中可以包含抽象方法和非抽象方法。抽象方法没有具体的实现，需要子类去实现。抽象类强调类之间的“是什么”关系，即子类“是一种”父类。抽象类适用于在类之间共享部分实现的情况。</p>
<p>以下是一个举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口：表示可飞行的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类：表示鸟类，包含共享的属性和方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：鹦鹉，继承自Bird类，实现Flyable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parrot</span> <span class="keyword">extends</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parrot</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parrot is flying.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parrot is singing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个 <code>Flyable</code> 接口和一个 <code>Bird</code> 抽象类。<code>Parrot</code> 类继承了 <code>Bird</code> 类，并实现了 <code>Flyable</code> 接口。这样，我们可以使用多态的特性，将 <code>Parrot</code> 类的对象赋值给 <code>Bird</code> 类型或 <code>Flyable</code> 类型的引用，并在运行时动态调用相应的方法。</p>
<p>总之，接口和抽象类都是实现多态的方式，但它们有不同的目的和使用场景。接口强调行为和功能，适用于定义通用的规范；抽象类强调类之间的关系，适用于在类之间共享部分实现。在实际的软件设计中，我们通常根据需求选择合适的方式来实现多态。</p>
<p>对于你提到的“为什么还有implements这一设计”的问题，这是因为Java不支持多重继承，即一个类不能继承多个父类。通过接口，我们可以实现类似多重继承的效果。接口允许我们定义一组行为，并可以被多个类实现，使得代码更加灵活和模块化。</p>
<p>关于抽象方法的存在意义，抽象方法强制子类去实现某些特定的行为。当我们定义一个抽象类时，我们可以预见到子类需要实现某些共同的行为，但这些行为的具体实现可能因子类而异。通过抽象方法，我们可以确保所有的子类都会实现这些行为，而不需要在每个子类中重复编写相同的代码。</p>
<p>例如，在上述的例子中，<code>Bird</code> 抽象类中的 <code>sing</code> 方法是一个抽象方法。这表示所有继承自 <code>Bird</code> 的子类都必须实现 <code>sing</code> 方法，以确保它们都具有唱歌的行为。这样，我们可以在处理 <code>Bird</code> 类型的对象时，确保它们都可以调用 <code>sing</code> 方法，而不需要关心具体的实现细节。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>多态的实现机制</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #实现机制 #示例 </p>
<blockquote>
<p>一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/FieldAccess.java </span></span><br><span class="line"><span class="comment">// Direct field access is determined at compile time </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> field; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>; </span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> field; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.field; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Super sup = <span class="keyword">new</span> Sub(); </span><br><span class="line">		<span class="comment">// Upcast </span></span><br><span class="line">		System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field + <span class="string">&quot;, sup.getField() = &quot;</span> + sup.getField()); </span><br><span class="line">		Sub sub = <span class="keyword">new</span> Sub(); </span><br><span class="line">		System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sub.field + <span class="string">&quot;, sub.getField() = &quot;</span> + sub.getField() + <span class="string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField()) </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出： sup.field = 0, sup.getField() = 1 sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0 </span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>我注意到上述的代码中 sup.field = 0, sup.getField() = 1，这样我对于 Java 底层实现多态的机制有些迷惑，他是如何确定到底是哪个方法要被执行的呢，是否是有个存储方法的栈之类的呢？</p>
</blockquote>
<p>在 Java 中，多态仅适用于方法调用，而不适用于字段访问。这就是为什么在上面的例子中，<code>sup.field</code> 的值为0，而 <code>sup.getField()</code> 的值为1。字段的访问在编译时就已经确定，而方法调用则在运行时动态绑定。</p>
<p>在这个例子中，当我们执行以下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Super sup = <span class="keyword">new</span> Sub(); <span class="comment">// Upcast</span></span><br></pre></td></tr></table></figure>
<p><code>sup</code> 是一个 <code>Super</code> 类型的引用，但它实际上引用了一个 <code>Sub</code> 类型的对象。当我们访问字段 <code>sup.field</code> 时，编译器在编译时就已经确定我们访问的是 <code>Super</code> 类型的 <code>field</code>，因此返回值为0。</p>
<p>然而，当我们调用 <code>sup.getField()</code> 时，JVM会在运行时检查<code>sup</code>引用的实际对象类型（即 <code>Sub</code> 类型），并调用 <code>Sub</code> 类中的 <code>getField()</code> 方法。这就是为什么 <code>sup.getField()</code> 返回1的原因。</p>
<p>多态背后的原理是利用了一种称为“虚方法表”（vtable）的机制。简而言之，当一个类被加载时，JVM会为其创建一个包含其所有方法的表。对于继承自父类的方法，子类中若有重写的方法，虚方法表中的对应条目将被子类方法替换。当我们通过一个引用调用一个方法时，JVM会根据引用的实际对象类型查找对应的虚方法表，然后调用表中对应的方法。</p>
<p>这就是Java实现多态的基本机制。要注意的是，多态仅适用于方法调用，不适用于字段访问。因此，在处理多态时，需要确保只通过方法调用来实现多态行为。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>实现机制</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title>开闭原则</title>
    <url>/2023/04/16/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #设计原则 #开闭原则 #面向对象设计</p>
<hr>
<p>开闭原则（Open-Closed Principle，OCP）是面向对象设计和编程中的一种重要设计原则。该原则的核心思想是：</p>
<p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在设计软件时，应当允许在不修改现有代码的情况下，添加新功能或者行为。</p>
<p>开闭原则的主要优点是提高了软件系统的可维护性和可复用性。遵循开闭原则可以使软件更容易适应变化，因为在添加新功能时，不需要对现有代码进行大量修改。这减少了引入新错误的风险，同时降低了维护成本。</p>
<p>为了实现开闭原则，通常需要使用以下技术和设计模式：</p>
<ol>
<li>抽象和封装：通过定义抽象类或接口，将可变的部分与不可变的部分分离，使得在不修改现有代码的情况下，可以通过继承或实现接口来扩展功能。</li>
<li>组合和聚合：通过将不同的功能模块组合在一起，可以在不修改现有代码的情况下，为系统添加新功能。</li>
<li>使用设计模式：很多设计模式，如策略模式、模板方法模式、装饰器模式等，都可以帮助实现开闭原则。</li>
</ol>
<p>当然，实际应用中，完全遵循开闭原则可能是非常困难的。然而，作为一种理念，开闭原则提醒我们在设计软件时要关注可维护性和可扩展性，尽量降低对现有代码的修改。</p>
]]></content>
      <tags>
        <tag>设计原则</tag>
        <tag>开闭原则</tag>
        <tag>面向对象设计</tag>
      </tags>
  </entry>
  <entry>
    <title>多态与接口的实际生产案例</title>
    <url>/2023/04/16/%E5%A4%9A%E6%80%81%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #多态 #接口 #实例</p>
<p>以下是一个简化的网球场地预约系统的例子，以展示多态和接口在实际生产中的应用。</p>
<p>首先，我们定义一个接口 <code>PaymentMethod</code>，表示不同的支付方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们为不同的支付方式创建实现类，例如 <code>CreditCard</code> 和 <code>PayPal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> <span class="keyword">implements</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing credit card payment: $&quot;</span> + amount);</span><br><span class="line">        <span class="comment">// 实际的信用卡支付处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPal</span> <span class="keyword">implements</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processPayment</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing PayPal payment: $&quot;</span> + amount);</span><br><span class="line">        <span class="comment">// 实际的PayPal支付处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们有一个 <code>Booking</code> 类，表示预约。这个类可以接受一个 <code>PaymentMethod</code> 类型的对象，以便在完成预约时处理支付：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Booking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentMethod paymentMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Booking</span><span class="params">(PaymentMethod paymentMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paymentMethod = paymentMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completeBooking</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Completing booking...&quot;</span>);</span><br><span class="line">        paymentMethod.processPayment(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了接口和多态的概念。<code>PaymentMethod</code> 接口定义了一个规范，而 <code>CreditCard</code> 和 <code>PayPal</code> 类提供了具体的实现。这样，我们可以灵活地为 <code>Booking</code> 类添加新的支付方式，而不需要修改 <code>Booking</code> 类的代码。多态使得我们可以将不同支付方式的实现类对象赋值给 <code>PaymentMethod</code> 类型的引用，从而在运行时动态调用正确的方法。</p>
<p>在实际生产中，我们可以利用这种设计更轻松地添加新的支付方式，例如 <code>Alipay</code>、<code>WeChatPay</code> 等，只需要创建新的实现类并实现 <code>PaymentMethod</code> 接口即可。</p>
<p>以下是一个简单的测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PaymentMethod creditCard = <span class="keyword">new</span> CreditCard();</span><br><span class="line">        PaymentMethod payPal = <span class="keyword">new</span> PayPal();</span><br><span class="line"></span><br><span class="line">        Booking booking1 = <span class="keyword">new</span> Booking(creditCard);</span><br><span class="line">        Booking booking2 = <span class="keyword">new</span> Booking(payPal);</span><br><span class="line"></span><br><span class="line">        booking1.completeBooking(<span class="number">100</span>);</span><br><span class="line">        booking2.completeBooking(<span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个例子，我们可以看到多态和接口在实际生产中的应用，以及它们是如何提高代码的灵活性和可扩展性的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>接口</tag>
        <tag>实例</tag>
      </tags>
  </entry>
  <entry>
    <title>构造器中调用动态绑定方法的隐患</title>
    <url>/2023/04/16/%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E6%82%A3/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #构造器 #动态绑定 #隐蔽的bug</p>
<hr>
<blockquote>
<p>如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。<br>———<br>为什么调用结果是难以预料的，举例解释下？ 为什么这些 bug 就是隐蔽的了呢？</p>
</blockquote>
<p>调用构造器中动态绑定方法的结果难以预料，是因为在对象完全构造出来之前，重写的方法就已经被调用。这可能导致不完全初始化的对象状态或数据。我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show(); <span class="comment">// 动态绑定方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived show, value: &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Derived derived = <span class="keyword">new</span> Derived();</span><br><span class="line">        derived.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Derived show, value: 0</span><br><span class="line">Derived show, value: 10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Derived</code> 类继承了 <code>Base</code> 类，并重写了 <code>show()</code> 方法。当我们创建一个 <code>Derived</code> 类的实例时，会先调用父类 <code>Base</code> 的构造器。在 <code>Base</code> 构造器中，调用了动态绑定方法 <code>show()</code>，此时会调用 <code>Derived</code> 类中重写的 <code>show()</code> 方法。然而，此时 <code>Derived</code> 类的构造器尚未执行，<code>value</code> 字段还没有被初始化为 10，所以输出的 <code>value</code> 值是 0。这就是为什么调用结果难以预料。</p>
<p>这些bug隐蔽的原因是，程序员可能没有意识到在构造器中调用动态绑定方法会导致这样的问题，而且问题表现为数据不一致，这使得在调试时难以发现问题的根源。因此，在构造器中调用动态绑定方法可能导致难以追踪和定位的bug。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>动态绑定</tag>
        <tag>构造器</tag>
        <tag>隐蔽的bug</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象和封装示例</title>
    <url>/2023/04/16/%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #抽象 #封装 #面向对象设计 #开闭原则 </p>
<hr>
<p>以下是一个关于图形绘制的例子，展示了如何使用抽象和封装实现开闭原则：</p>
<p>首先，我们创建一个抽象类<code>Shape</code>，定义了一个抽象方法<code>draw()</code>，用于绘制图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以创建不同的图形类，如 <code>Circle</code> 和 <code>Rectangle</code>，分别继承 <code>Shape</code> 类，并实现 <code>draw()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制一个圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制一个矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以创建一个 <code>Drawing</code> 类，它接收一个 <code>Shape</code> 类型的列表，并提供一个 <code>drawAll()</code> 方法来绘制所有图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Shape&gt; shapes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(List&lt;Shape&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shapes = shapes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们通过抽象类 <code>Shape</code> 将图形的绘制行为抽象出来，并通过封装将不同图形的具体实现细节隐藏起来。这样，当我们需要添加新的图形类型时（例如三角形），只需要创建一个新的类（如 <code>Triangle</code>），继承 <code>Shape</code> 并实现 <code>draw()</code> 方法。我们不需要修改 <code>Drawing</code> 类或其他现有代码。</p>
<p>这个例子展示了如何通过抽象和封装实现开闭原则，使得软件系统易于扩展和维护。</p>
]]></content>
      <tags>
        <tag>开闭原则</tag>
        <tag>面向对象设计</tag>
        <tag>抽象</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象方法与接口在概念上的异同</title>
    <url>/2023/04/16/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%9C%A8%E6%A6%82%E5%BF%B5%E4%B8%8A%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #抽象类 #抽象概念 #接口 #约束机制 #继承 #抽象方法 #父类 #子类 </p>
<hr>
<blockquote>
<p>在一定程度上，我是否可以理解为一个父类中的抽象方法就是这个父类承诺的这个类的子类们自身要实现的所有方法，如果将接口比喻成一个标签用以表示一个类承诺实现了这个标签所代表的所有方法，那么抽象方法本身也是一种形式的标签</p>
</blockquote>
<p>是的，在一定程度上，你可以这样理解。抽象方法是父类对子类的一种约束，表示子类必须实现这个方法。这种约束关系确保了在父类中定义的抽象方法在所有子类中都有具体的实现。从这个角度看，抽象方法确实可以看作是一种”标签”，它告诉子类应该实现某些行为。</p>
<p>与接口相比，抽象方法在父类中定义，而接口是一种独立的结构，可以被多个类实现。接口也可以看作是一种”标签”，表示实现了该接口的类承诺实现了接口中定义的所有方法。</p>
<p>总的来说，抽象方法和接口都是一种约束机制，用于确保实现它们的类具有某些特定的行为。抽象方法主要用于继承关系中，而接口则可以实现更灵活的多重继承效果。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
        <tag>抽象概念</tag>
        <tag>约束机制</tag>
        <tag>抽象方法</tag>
        <tag>父类</tag>
        <tag>子类</tag>
      </tags>
  </entry>
  <entry>
    <title>理解纯is-a关系和is-like-a关系</title>
    <url>/2023/04/16/%E7%90%86%E8%A7%A3%E7%BA%AFis-a%E5%85%B3%E7%B3%BB%E5%92%8Cis-like-a%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #多态 #继承 #is-a关系 #is-like-a关系</p>
<hr>
<p>这段文字主要在讨论两种不同的继承关系：纯 is-a 关系和 is-like-a 关系。</p>
<ol>
<li> 纯is-a关系：在这种关系中，子类只覆盖（重写）基类的方法，而不添加任何新方法。这意味着子类对象可以完美地替换基类对象，因为它们具有相同的接口。在这种情况下，多态会处理一切，你不需要知道子类的额外信息。</li>
</ol>
<p>这种方式看起来是继承的理想方式，但它并非适用于所有场景。</p>
<ol start="2">
<li> is-like-a关系：在这种关系中，子类不仅覆盖基类的方法，还扩展了基类的接口，添加了额外的方法。子类与基类具有相同的基本接口，但还具有其他特性，需要额外的方法来实现。</li>
</ol>
<p>这种方法在某些情况下也是有用的，但它有一个缺点。一旦你向上转型（upcast），你就不能调用子类中扩展的那部分接口的方法。在某些情况下，你可能需要重新发现对象的确切类型，以便访问该类型的扩展方法。</p>
<p>这段文字的目的是让你了解在设计类的继承结构时，可能会遇到这两种不同的情况。在日常开发过程中，根据问题的具体需求，你可能会遇到这两种情况。关键是理解这两种关系的优缺点，并在实际情况中做出合适的设计选择。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多态</tag>
        <tag>is-like-a关系</tag>
        <tag>继承</tag>
        <tag>is-a关系</tag>
      </tags>
  </entry>
  <entry>
    <title>理解接口（Interface）的抽象概念</title>
    <url>/2023/04/16/%E7%90%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%EF%BC%88Interface%EF%BC%89%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #接口 #面向对象 #抽象概念</p>
<hr>
<blockquote>
<p>我注意到一件事，在我们学习 onjava8这本书的时候，里面是不是的会提及接口（interface）这一概念，但是有的时候似乎并不是说的关键字 interface，而是一种抽象概念的接口—用以表达的是一个类对外开放的那些实现的方，是一种基于 java 面向对象思想而设计的一种抽象层面，即，对外提供接口而不暴露具体实现的这么一种思想，的表述？</p>
</blockquote>
<p>你的理解是正确的。在 Java 中，当我们谈论接口（interface）时，它可能有两层含义。一种是具体的关键字 <code>interface</code>，它用于创建一种特殊的类型，这种类型只包含抽象方法和静态常量。另一种含义是抽象概念上的接口，它表示一个类对外暴露的方法和属性，用于与其他类进行交互。</p>
<p>抽象概念上的接口强调了面向对象编程的一种思想：封装。封装是指将实现细节隐藏起来，仅向外界提供有限的、可控的访问途径。这样，外部代码只需要关注类的接口（即暴露的方法和属性），而不需要了解其内部实现。这使得我们可以在不影响其他代码的情况下，随时更改类的内部实现。</p>
<p>Java的关键字 <code>interface</code> 实际上也是基于这种抽象概念的接口思想设计的。通过使用关键字 <code>interface</code> 创建的接口类型，我们可以定义一组方法，表示一种规范或协议，实现该接口的类需要遵循这个规范。这样，我们就可以基于接口而非具体实现编写代码，从而提高了代码的灵活性和可扩展性。</p>
<p>总之，Java中的接口（interface）既可以表示一种具体的类型（关键字 <code>interface</code>），也可以表示一种抽象概念（类对外暴露的方法和属性）。这两种含义都是基于面向对象编程的封装思想而设计的，旨在提高代码的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象概念</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>编写构造器的一条良好规范</title>
    <url>/2023/04/16/%E7%BC%96%E5%86%99%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%B8%80%E6%9D%A1%E8%89%AF%E5%A5%BD%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 <strong>final</strong> 方法（这也适用于可被看作是 <strong>final</strong> 的 <strong>private</strong> 方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。</p>
]]></content>
  </entry>
  <entry>
    <title>Fold Level</title>
    <url>/2023/04/23/Fold%20Level/</url>
    <content><![CDATA[<p>时间：2023-04-19<br>标签： #VSCode #ExtensionPack </p>
<hr>
<h1 id="Usage-amp-Commands"><a href="#Usage-amp-Commands" class="headerlink" title="Usage &amp; Commands"></a>Usage &amp; Commands</h1><p>Set shortcuts:</p>
<ol>
<li>Press<ul>
<li>  Mac: <code>Command + Shift + p</code></li>
<li>  Win: <code>Ctrl + Shift + p</code></li>
</ul>
</li>
<li> <code>Open Keyboard Shortcuts File</code></li>
<li>Append:</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+1&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+2&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level2&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+3&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level3&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+4&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level4&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+5&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level5&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+6&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;vikyd.FoldLevel.level6&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ↓  optional</span></span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+-&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;editor.foldAll&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ↓  optional</span></span><br><span class="line">&#123;    </span><br><span class="line">	<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;alt+=&quot;</span>,    </span><br><span class="line">	<span class="attr">&quot;command&quot;</span>: <span class="string">&quot;editor.unfoldAll&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>ExtensionPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中this的使用</title>
    <url>/2023/04/19/Java%E4%B8%ADthis%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #this关键字</p>
<hr>
<p>在 Java 中，<code>this</code> 是一个特殊的关键字，它可以在类的实例方法或构造器中使用，用于引用当前对象。<code>this</code> 的主要用途包括以下几点：</p>
<ol>
<li><p> <strong>解决实例变量和局部变量之间的命名冲突</strong>：当实例变量和方法中的局部变量或参数具有相同的名称时，可以使用 <code>this</code> 关键字引用实例变量。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，构造函数的参数 <code>name</code> 和实例变量 <code>name</code> 具有相同的名称。使用 <code>this.name</code> 来引用实例变量，从而避免命名冲突。</p>
</li>
<li><p> <strong>在构造器中调用另一个构造器</strong>：<code>this</code>关键字还可以用于构造器中调用同一类的另一个构造器。这通常用于减少重复代码。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，有两个构造器。第一个构造器接受一个 <code>name</code> 参数，它使用 <code>this(name, 0)</code> 调用第二个构造器，将 <code>age</code> 参数设置为0。</p>
</li>
<li><p> <strong>链式方法调用</strong>：有时候，方法可能会返回 <code>this</code> 引用，从而实现链式调用。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>setName</code> 和 <code>setAge</code> 方法都返回 <code>this</code> 引用，这使得我们可以进行链式调用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee employee = <span class="keyword">new</span> Employee().setName(<span class="string">&quot;Alice&quot;</span>).setAge(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>总之，Java中的<code>this</code>关键字用于引用当前对象，它在解决命名冲突、调用其他构造器和实现链式方法调用等场景中非常有用。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>this关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中为什么使用 super 表示父类而不是 base</title>
    <url>/2023/04/19/Java%20%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20super%20%E8%A1%A8%E7%A4%BA%E7%88%B6%E7%B1%BB%E8%80%8C%E4%B8%8D%E6%98%AF%20base/</url>
    <content><![CDATA[<p>时间：2023-04-11<br>标签： #Java #super #父类 #历史背景</p>
<hr>
<blockquote>
<p>为什么我们在 java 中使用 super 来表示父类而不是用 base，这是因为什么原因，有什么历史因素或背后的故事么</p>
</blockquote>
<p>在 Java 中，我们使用 super 关键字来表示父类，而不是使用 base。这个设计决策的背后有一定的历史因素和原因：</p>
<ol>
<li><p>语言设计者的选择：<br>Java 的创建者 James Gosling 和他的团队在设计 Java 语言时，选择了”super”作为访问父类成员的关键字。这种选择可能是基于他们的编程经验、对现有编程语言的了解，以及他们对 Java 语言的愿景。</p>
</li>
<li><p>与其他语言的区分：<br>当时已有的一些编程语言，如 C++和 Object Pascal（Delphi）等，使用其他关键字表示父类。例如，C++中使用”:: “操作符，Object Pascal 中使用”inherited”关键字。Java 选择使用 super 作为父类表示，可以帮助区分这些编程语言。</p>
</li>
<li><p>表达清晰：<br>Super 这个词在英语中表示”上级”或”超级”，在这个语境下，表示”父类”是合适的。这个词简洁、易懂，可以清晰地表达出父类的概念。</p>
</li>
</ol>
<p>总之，Java 中使用 super 表示父类而不是 base，主要是由于语言设计者的选择和对其他编程语言的区分。在实际编程过程中，使用 super 关键字可以清晰地表示出访问父类成员的意图，使代码易于理解。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>父类</tag>
        <tag>super</tag>
        <tag>历史背景</tag>
      </tags>
  </entry>
  <entry>
    <title>Path 与 Paths 的关系与区别</title>
    <url>/2023/04/19/Path%20%E4%B8%8E%20Paths%20%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #Path #Paths</p>
<hr>
<blockquote>
<p>import java.nio.file.Paths; import java.nio.file.Path; 为什么会存在两个歧义性很高的两个包在同一个包下，二者的功能的区别是什么</p>
</blockquote>
<p>在这个例子中，我们使用了两个不同的类，它们都在 <code>java.nio.file</code> 包中：<code>Paths</code> 和 <code>Path</code>。虽然它们的名称很相似，但它们具有不同的功能和用途。</p>
<ol>
<li><code>java.nio.file.Path</code>：<code>Path</code> 是一个接口，表示文件系统中文件或目录的路径。它提供了一种在文件系统中导航和操作文件的方法。<code>Path</code> 对象包含了路径信息，可以用来创建、删除、读取和修改文件或目录。</li>
<li><code>java.nio.file.Paths</code>：<code>Paths</code> 是一个工具类，包含一些静态方法，用于创建 <code>Path</code> 对象。它是一个方便的工具类，用于将字符串路径转换为 <code>Path</code> 对象，以便在文件系统中进行操作。</li>
</ol>
<p>虽然它们的名字很相似，但它们的功能是互补的。我们通常使用 <code>Paths</code> 类中的静态方法创建一个 <code>Path</code> 对象，然后使用 <code>Path</code> 对象来操作和访问文件系统。</p>
<p>在本例中，我们使用 <code>Paths.get()</code> 方法将字符串形式的目录路径转换为 <code>Path</code> 对象。接着，我们使用 <code>Path</code> 对象来操作文件路径，例如获取文件名（<code>path.getFileName().toString()</code>）。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Path</tag>
        <tag>Paths</tag>
      </tags>
  </entry>
  <entry>
    <title>Set&lt;Integer&gt; 转换为一个 int 数组</title>
    <url>/2023/04/19/Set%3CInteger%3E%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AA%20int%20%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #Set #数组 </p>
<hr>
<p>如果你想将一个 <code>Set&lt;Integer&gt;</code> 转换为一个 <code>int[]</code> 数组，你可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Set&lt;Integer&gt;</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Set&lt;Integer&gt; 转换为 int[]</span></span><br><span class="line">        <span class="keyword">int</span>[] intArray = set.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : intArray) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用 Java 8 引入的 Stream API。首先，我们通过调用 <code>set.stream()</code> 获取一个 <code>Stream&lt;Integer&gt;</code>，然后使用 <code>mapToInt()</code> 方法将每个 <code>Integer</code> 对象转换为对应的基本类型 <code>int</code>。最后，我们调用 <code>toArray()</code> 方法将流转换为 <code>int[]</code> 数组。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Set</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code 中的 Source Actions 功能简介</title>
    <url>/2023/04/19/Visual%20Studio%20Code%20%E4%B8%AD%E7%9A%84%20Source%20Actions%20%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #VisualStudioCode #VSCode #SourceActions #代码重构 #代码生成 #开发工具 </p>
<hr>
<p>在 Visual Studio Code 中，Source Actions 是一组针对源代码进行操作的快捷功能。它们可以帮助您自动执行常见的代码重构和改进任务，例如排序导入、移除未使用的导入、自动生成方法实现等。这些功能可以提高开发效率，减少手动修改代码的需求。</p>
<p>以下是一些常见的 Source Actions：</p>
<ol>
<li> **Organize Imports (整理导入)**：自动整理和优化当前文件的导入语句。它会删除未使用的导入，同时按字母顺序或其他规则对导入进行排序。</li>
<li> **Generate Getters and Setters (生成 getter 和 setter 方法)**：针对选定的类属性自动生成 getter 和 setter 方法。这可以方便地封装类的内部实现，提供统一的访问接口。</li>
<li> **Generate Constructors (生成构造函数)**：自动生成构造函数，以便根据类的属性初始化对象。</li>
<li> **Generate toString(), hashCode() and equals() methods (生成 toString()、hashCode() 和 equals() 方法)**：自动生成类的 toString()、hashCode() 和 equals() 方法，用于实现对象的字符串表示、哈希计算和相等性判断。</li>
<li> **Extract Method (提取方法)**：将选定的代码片段提取到一个新的方法中，以便重用和简化代码。</li>
<li> **Extract Variable (提取变量)**：将选定的表达式提取到一个新的变量中，以便重用和简化代码。</li>
</ol>
<p>要使用 Source Actions，您可以右键单击编辑器中的代码，然后选择 “Source Action” 菜单。此外，您还可以打开命令面板（按 <code>Ctrl+Shift+P</code> 或 <code>Cmd+Shift+P</code>），然后输入 “Source Action” 来查找和执行相应的操作。在使用特定编程语言时，可能需要安装相应的扩展以启用 Source Actions 功能。例如，在使用 Java 时，可以安装 “Java Extension Pack” 扩展来启用这些功能。</p>
<p>原本 Source Actions 功能并没有设置快捷键，在我们按下 <code>Ctrl+Shift+P</code> 或  <code>Cmd+Shift+P </code>并输入”Source Action” 后，相应的后面有一个齿轮图标，点击该图标按钮可以在弹出的页面中为该功能设置快捷键，例如，<code>Cmd+option+a</code></p>
]]></content>
      <tags>
        <tag>VisualStudioCode</tag>
        <tag>VSCode</tag>
        <tag>SourceActions</tag>
        <tag>代码重构</tag>
        <tag>代码生成</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>onJava8-接口-摘录</title>
    <url>/2023/04/19/onJava8-%E6%8E%A5%E5%8F%A3-%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #java #接口 #摘录 </p>
<hr>
<p>一个接口表示 ：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。</p>
<p>接口同样可以包含属性，这些属性被隐式指明为 <strong>static</strong> 和 <strong>final</strong>。</p>
<p>方法签名包括方法名和参数类型 – 返回类型不算在方法签名里。</p>
<p>Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具</p>
<p>有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。</p>
<p>使用接口的核心原因之一：为了能够向上转型为多个基类型（以及由此带来的灵活性）。然而，使用接口的第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。这带来了一个问题：应该使用接口还是抽象类呢？如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。事实上，如果知道某事物是一个基类，可以考虑用接口实现它</p>
<p>认为接口是好的选择，从而使用接口不用具体类，这具有诱惑性。几乎任何时候，创建类都可以替代为创建一个接口和工厂。</p>
<p>很多人都掉进了这个陷阱，只要有可能就创建接口和工厂。这种逻辑看起来像是可能会使用不同的实现，所以总是添加这种抽象性。==这变成了一种过早的设计优化==。</p>
<p>任何抽象性都应该是由真正的需求驱动的。当有必要时才应该使用接口进行重构，而不是到处添加额外的间接层，从而带来额外的复杂性。这种复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到“以防万一”而添加新接口，而没有其他具有说服力的原因——好吧，如果我碰上了这种设计，就会质疑此人所作的所有其他设计了。</p>
<p>恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。</p>
]]></content>
      <tags>
        <tag>接口</tag>
        <tag>java</tag>
        <tag>摘录</tag>
      </tags>
  </entry>
  <entry>
    <title>bashrc 与 zshrc的区别</title>
    <url>/2023/04/19/bashrc%20%E4%B8%8E%20zshrc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #bash #zsh </p>
<hr>
<p><code>~/.bashrc</code>（Bash 用户）和 <code>~/.zshrc</code>（Zsh 用户）是 shell 配置文件。它们分别为 Bash 和 Zsh shell 提供配置和个性化设置。当您打开一个新的终端会话时，系统会自动加载这些配置文件，从而应用您为 shell 定义的任何自定义设置、别名、环境变量等。</p>
<ol>
<li><strong>Bash</strong>：Bash（Bourne Again Shell）是许多Linux发行版中默认的shell。macOS的早期版本也使用了Bash作为默认shell。<code>~/.bashrc</code>文件用于为Bash shell提供个性化设置。它可以包含您希望在每个新的终端会话中自动执行的命令和设置，例如定义别名、设置环境变量和更改提示符样式。</li>
<li><strong>Zsh</strong>：Zsh（Z shell）是另一种流行的Unix shell，它为用户提供了一些额外的功能，如命令补全、主题和插件支持。从macOS Catalina开始，Zsh成为macOS的默认shell。<code>~/.zshrc</code>文件用于为Zsh shell提供个性化设置，其功能与<code>~/.bashrc</code>相似，但针对Zsh shell。</li>
</ol>
<p>您只有<code>~/.zshrc</code>文件可能是因为您的系统使用Zsh作为默认shell。要确认当前正在使用的shell，请在终端中运行以下命令：</p>
<p>bashCopy code</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<p>这将显示您正在使用的shell，例如<code>/bin/bash</code>或<code>/bin/zsh</code>。</p>
<p>您可以根据需要在<code>~/.zshrc</code>文件中添加自定义设置、别名和环境变量。要编辑此文件，您可以使用文本编辑器（例如<code>nano</code>、<code>vim</code>或<code>Visual Studio Code</code>）打开它，然后保存更改。在更改配置文件后，请确保运行<code>source ~/.zshrc</code>命令以使更改生效。</p>
]]></content>
      <tags>
        <tag>bash</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的回调机制及其优势</title>
    <url>/2023/04/19/Java%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8A%BF/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #回调 #异步编程 #事件驱动编程 #接口 #自定义行为 #编程模式 </p>
<hr>
<p>回调（Callback）是一种编程模式，它允许将一个函数（或方法）作为参数传递给另一个函数（或方法）。当被调用的函数执行完毕后，会调用传递进来的回调函数，以完成某些特定任务或通知调用者任务已完成。这种编程方式在异步编程、事件处理和自定义函数行为等场景中非常有用。</p>
<p>关于 Java 没有回调的说法，并不准确。Java 实际上支持回调，但它实现回调的方式与其他语言（如 JavaScript）略有不同。在 Java 中，我们通常使用接口来实现回调。以下是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFinished</span><span class="params">(String result)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行某些任务</span></span><br><span class="line">        String result = <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用回调函数</span></span><br><span class="line">        callback.onFinished(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.doWork(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinished</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;回调结果: &quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个名为 <code>Callback</code> 的接口，然后在 <code>Worker</code> 类的 <code>doWork</code> 方法中接受一个实现了 <code>Callback</code> 接口的对象。这样，在 <code>doWork</code> 方法完成任务后，可以调用回调函数 <code>onFinished</code>。</p>
<p>回调的主要机制和好处如下：</p>
<ol>
<li>异步编程：回调使得程序可以在执行耗时操作时，不阻塞其他操作的进行。一旦耗时操作完成，回调函数会被触发，从而实现异步编程。</li>
<li>事件驱动编程：回调可以用来实现事件驱动编程，当特定事件发生时触发相应的回调函数。这种方式使得代码更具可扩展性和可维护性。</li>
<li>自定义行为：通过将回调函数作为参数传递，可以让调用者自定义函数的行为，提高代码的复用性和灵活性。</li>
</ol>
<p>虽然回调有很多好处，但过度使用回调可能导致代码变得难以理解和维护，这种现象被称为“回调地狱”。为了解决这个问题，可以使用更高级的抽象概念，如Java中的<code>Future</code>、<code>CompletableFuture</code>和<code>Stream</code>等。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>回调</tag>
        <tag>异步编程</tag>
        <tag>事件驱动编程</tag>
        <tag>自定义行为</tag>
        <tag>编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>unicode</title>
    <url>/2023/04/19/unicode/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #java #unicode</p>
<hr>
<p>Unicode 是一种字符集，用于表示和处理世界上大多数书面语言中的文本。在 Unicode 中，英文字符的编码范围在 U+0020 到 U+007E 之间，包括了英文字母、数字、标点符号以及一些其他特殊字符。以下是一些常见英文字符的 Unicode 编码：</p>
<ul>
<li>  大写英文字母：从 U+0041 (A) 到 U+005A (Z)</li>
<li>  小写英文字母：从 U+0061 (a) 到 U+007A (z)</li>
<li>  数字：从 U+0030 (0) 到 U+0039 (9)</li>
<li>  空格：U+0020 ( )</li>
<li>  常见标点符号：如 U+002C (,), U+002E (.), U+003A (:), U+003B (;) 等。</li>
</ul>
<p>请注意，Unicode 字符集包含了许多其他字符，不仅仅是英文字符。它包括了其他语言的字符、表情符号、数学符号等等。Unicode 提供了一种统一的方式来表示和处理多种语言和符号系统。</p>
<p>在 Unicode 中，U+005A 和 U+0061 之间的字符如下：</p>
<ul>
<li>  U+005A：大写字母 Z</li>
<li>  U+005B：左方括号 [</li>
<li>  U+005C：反斜杠 \</li>
<li>  U+005D：右方括号 ]</li>
<li>  U+005E：脱字符 ^</li>
<li>  U+005F：下划线 _</li>
<li>  U+0060：反引号 `</li>
<li>  U+0061：小写字母 a</li>
</ul>
<p>这些字符主要包括一些特殊字符和标点符号，以及英文大小写字母的分界点。</p>
<p>在 Unicode 中，数字的编码范围如下：</p>
<ul>
<li>  U+0030：数字 0</li>
<li>  U+0031：数字 1</li>
<li>  U+0032：数字 2</li>
<li>  U+0033：数字 3</li>
<li>  U+0034：数字 4</li>
<li>  U+0035：数字 5</li>
<li>  U+0036：数字 6</li>
<li>  U+0037：数字 7</li>
<li>  U+0038：数字 8</li>
<li>  U+0039：数字 9</li>
</ul>
<p>这些数字的 Unicode 编码从 U+0030（数字 0）开始，依次递增到 U+0039（数字 9）。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>一个方法里面或者在任意的作用域内定义内部类</title>
    <url>/2023/04/19/%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E6%88%96%E8%80%85%E5%9C%A8%E4%BB%BB%E6%84%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E5%AE%9A%E4%B9%89%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #内部类 </p>
<hr>
<p>在一个方法里面或者在任意的作用域内定义内部类。</p>
<p>这么做有两个理由：</p>
<ol>
<li> 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。</li>
<li> 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh command not found hexo</title>
    <url>/2023/04/19/zsh%20command%20not%20found%20hexo/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #zsh #hexo #环境配置</p>
<hr>
<blockquote>
<p>zsh: command not found: hexo</p>
</blockquote>
<p>这个错误通常是由于 Hexo 没有正确安装或者没有将其添加到系统路径中导致的。请按照以下步骤尝试解决这个问题：</p>
<ol>
<li><p> 确保您已经安装了 Node.js 和 npm。您可以在命令行中运行以下命令来检查它们的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>如果您还没有安装它们，请访问 <a href="https://nodejs.org/">Node.js官方网站</a>下载并安装相应的版本。</p>
</li>
<li><p> 全局安装 Hexo。在命令行中运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>这将在全局范围内安装 Hexo 命令行工具。在安装过程中，可能需要管理员权限。</p>
</li>
<li><p> 检查 Hexo 是否已成功安装。在命令行中运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>如果您看到了 Hexo 的版本信息，那么说明 Hexo 已经成功安装。接下来，您可以继续按照之前的说明操作。</p>
</li>
</ol>
<p>如果您仍然遇到“command not found”的错误，那么可能是因为Hexo的可执行文件没有被添加到系统路径中。请按照以下步骤进行操作：</p>
<ol>
<li><p> 找到 Hexo 的安装路径。运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>
<p>这将显示 npm 的全局安装路径。Hexo 的可执行文件通常位于该路径下的 <code>bin</code> 文件夹中。</p>
</li>
<li><p> 将Hexo的可执行文件路径添加到系统路径中。对于macOS和Linux用户，您需要编辑<code>~/.bashrc</code>（Bash用户）或<code>~/.zshrc</code>（Zsh用户）文件。对于Windows用户，您需要编辑环境变量。具体操作方法如下：</p>
</li>
</ol>
<ul>
<li>  <strong>macOS/Linux</strong>：打开 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件，添加以下内容（==替换 <code>&lt;npm-global-path&gt;</code> 为实际路径==）：<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&lt;npm-global-path&gt;/bin</span><br></pre></td></tr></table></figure>
然后运行以下命令以使更改生效：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
或<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li>
<li>  <strong>Windows</strong>：右键点击“计算机”（或“此电脑”）图标，选择“属性”。在“系统”窗口中，点击“高级系统设置” &gt; “环境变量”。在“系统变量”区域中，找到名为“Path”的变量，点击“编辑”按钮。在“编辑环境变量”窗口中，将Hexo的可执行文件路径（<code>&lt;npm-global-path&gt;\bin</code>）添加到变量值中。请注意，不同路径之间应使用分号（<code>;</code>）分隔。</li>
</ul>
]]></content>
      <tags>
        <tag>zsh</tag>
        <tag>hexo</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Integer.toString(i)是静态方法而不是i.toString()</title>
    <url>/2023/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88Integer.toString(i)%E6%98%AF%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AFi.toString()/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #Integer #静态方法</p>
<hr>
<p>Java 中 <code>Integer.toString(i)</code> 使用静态方法的原因主要有以下几点：</p>
<ol>
<li><strong>基本类型与包装类</strong>：Java中的<code>int</code>是基本类型，而非对象。基本类型没有方法，因此不能像对象一样调用方法（如<code>i.toString()</code>）。为了解决这个问题，Java提供了<code>Integer</code>包装类，它包含一些静态方法，如<code>toString()</code>，可以将基本类型<code>int</code>转换为字符串表示。</li>
<li><strong>性能考虑</strong>：将<code>int</code>类型值转换为字符串表示时，使用静态方法可以避免创建不必要的<code>Integer</code>对象。如果使用<code>i.toString()</code>，需要先将<code>int</code>类型转换为<code>Integer</code>对象，然后调用<code>toString()</code>方法。这会产生额外的对象创建和垃圾回收开销。</li>
<li><strong>易用性</strong>：静态方法可以直接使用类名调用，而无需创建对象。这使得<code>Integer.toString(i)</code>在使用上更加简便。</li>
</ol>
<p>总之，<code>Integer.toString(i)</code>设计为静态方法，主要是为了解决基本类型与包装类之间的差异，提高性能，并提供更简便的使用方式。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>静态方法</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么在用vscode运行代码的时候没有生成class文件</title>
    <url>/2023/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E7%94%A8vscode%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E6%B2%A1%E6%9C%89%E7%94%9F%E6%88%90class%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #VSCode #Java #Class </p>
<hr>
<p>在使用 VSCode 编写并运行 Java 代码时，默认情况下，编译生成的 <code>.class</code> 文件通常存储在内存中，并不会直接在文件系统中生成。这使得运行 Java 代码更加高效，因为不需要频繁地读写磁盘。这也是为什么你在项目目录下没有看到 <code>.class</code> 文件的原因。</p>
<p>但是，如果你希望查看或保存生成的<code>.class</code>文件，可以通过以下步骤将它们输出到项目目录中：</p>
<ol>
<li><p> 在VSCode中，打开Settings（快捷键<code>Ctrl+,</code>），然后点击右上角的“Open Settings (JSON)”图标，这将打开<code>settings.json</code>文件。</p>
</li>
<li><p> 在 <code>settings.json</code> 文件中，添加以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;java.debug.settings.console&quot;</span>: <span class="string">&quot;internalConsole&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;java.dependency.outputPath&quot;</span>: <span class="string">&quot;output&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;java.project.outputPath&quot;</span>: <span class="string">&quot;output&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们将 <code>java.project.outputPath</code> 设置为 <code>output</code>。这意味着编译生成的 <code>.class</code> 文件将被保存到名为 <code>output</code> 的文件夹中。你可以根据自己的需求更改该值。</p>
</li>
<li><p> 保存<code>settings.json</code>文件，然后重新运行你的Java程序。</p>
</li>
</ol>
<p>现在，在你指定的输出文件夹（如<code>output</code>）中，你应该能够看到生成的<code>.class</code>文件。请注意，这种做法会在磁盘上生成额外的文件，可能会影响性能。在开发过程中，通常不需要将<code>.class</code>文件保存到磁盘。这种方法主要用于调试或特殊需求。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>VSCode</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么称之为基类子对象而不是派生类对象</title>
    <url>/2023/04/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>时间：2023-04-11<br>标签： #Java #继承 #基类 #派生类 #子对象</p>
<hr>
<p>首先，我们需要明确一点：基类子对象和派生类对象是不同的概念。我们来分析一下这两个概念的含义和区别：</p>
<ol>
<li>基类子对象：<ul>
<li>  基类子对象是指派生类对象中与基类对应的部分。当我们创建一个派生类的对象时，这个对象实际上包含了基类的一个实例，即基类子对象。基类子对象包含了继承自基类的属性和方法。</li>
</ul>
</li>
<li>派生类对象：<ul>
<li>  派生类对象是指一个派生类的实例。它包含了基类子对象以及派生类特有的属性和方法。从外部看，派生类对象具有基类的接口（属性和方法），同时还可能具有一些额外的方法和字段。</li>
</ul>
</li>
</ol>
<p>我们称之为基类子对象，是为了强调这部分对象与基类的关联，以及它在派生类对象中的地位。基类子对象是派生类对象的一部分，它体现了继承关系中基类对派生类的影响。</p>
<p>而派生类对象是一个更宽泛的概念，它包括了基类子对象和派生类特有的属性和方法。因此，在讨论继承关系中基类在派生类对象中的表现时，我们更倾向于使用“基类子对象”这个术语，以区分它与整个派生类对象的区别。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>基类</tag>
        <tag>派生类</tag>
        <tag>子对象</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Java 中的 var 关键字简化代码</title>
    <url>/2023/04/19/%E4%BD%BF%E7%94%A8%20Java%20%E4%B8%AD%E7%9A%84%20var%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #JDK10</p>
<hr>
<p>Java 10 引入了一个新的关键字 <code>var</code>，用于支持局部变量类型推断。本文将探讨使用 <code>var</code> 的优点、局限性以及在实际代码中的应用。</p>
<h3 id="为什么要使用-var？"><a href="#为什么要使用-var？" class="headerlink" title="为什么要使用 var？"></a>为什么要使用 var？</h3><p>使用 <code>var</code> 的主要目的是为了提高代码的简洁性和可读性。使用 <code>var</code> 可以让编译器自动推断变量的类型，从而避免在声明变量时显式地指定类型。</p>
<p>以下是使用 <code>var</code> 的一些优点：</p>
<ol>
<li> <strong>简洁性</strong>：使用 <code>var</code> 可以减少代码冗余。在声明具有复杂类型的变量时，使用 <code>var</code> 可以简化代码。</li>
<li> <strong>可读性</strong>：<code>var</code> 有助于提高代码的可读性。当变量的类型可以从上下文或初始化表达式中推断时，使用 <code>var</code> 可以使代码更容易阅读。</li>
<li> <strong>改进重构</strong>：使用 <code>var</code> 可以使重构过程更加简单。当修改变量的类型时，使用 <code>var</code> 可以减少需要更改的代码量。</li>
</ol>
<h3 id="var-的局限性"><a href="#var-的局限性" class="headerlink" title="var 的局限性"></a>var 的局限性</h3><p>尽管 <code>var</code> 提供了许多便利，但它也有一些限制：</p>
<ol>
<li> 只能用于局部变量，不能用于方法参数、返回类型、字段等。</li>
<li> 在某些情况下，过度使用 <code>var</code> 可能导致代码可读性降低。</li>
</ol>
<p>因此，在使用 <code>var</code> 时需要权衡代码的简洁性和可读性。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下示例展示了如何在实际代码中使用 <code>var</code>。</p>
<p><strong>不使用 var</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(inputStream,</span><br><span class="line">												 StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p><strong>使用 var</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>在这些示例中，使用 <code>var</code> 可以简化代码，并提高可读性。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Java 中的 <code>var</code> 关键字为局部变量类型推断提供了一种简洁且易于阅读的方法。在实际项目中，开发者可以根据具体需求和场景来决定是否使用 <code>var</code>。同时，要注意在使用 <code>var</code> 时不要过度简化代码，以免降低代码可读性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JDK10</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub Pages搭建个人博客网站</title>
    <url>/2023/04/19/%E4%BD%BF%E7%94%A8GitHub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签: #GitHub #GitHubPages #个人博客 #Markdown #静态网站</p>
<hr>
<p>根据您的需求，我将为您提供一个简单的执行框架。在执行过程中，您可以随时告诉我您已完成的步骤，我会为您提供详细的说明和指导。</p>
<ol>
<li>创建一个GitHub帐户并设置GitHub Pages<ul>
<li>  注册GitHub帐户</li>
<li>  新建一个仓库</li>
<li>  在仓库设置中启用GitHub Pages</li>
</ul>
</li>
<li>选择一个静态网站生成器<ul>
<li>  推荐使用Jekyll或Hugo等流行的静态网站生成器</li>
</ul>
</li>
<li>设置和配置静态网站生成器<ul>
<li>  安装所选静态网站生成器</li>
<li>  为博客选择一个主题</li>
<li>  配置相关设置</li>
</ul>
</li>
<li>使用Markdown编写博客文章<ul>
<li>  创建一个新的Markdown文件</li>
<li>  使用Markdown语法编写内容</li>
<li>  添加元数据（如标题、日期等）</li>
</ul>
</li>
<li>发布博客文章<ul>
<li>  将博客文章添加到仓库</li>
<li>  提交更改并推送到GitHub</li>
<li>  检查GitHub Pages上的博客更新</li>
</ul>
</li>
<li>优化博客网站<ul>
<li>  添加可交互的插件</li>
<li>  优化样式和功能</li>
<li>  确保数据迁移和工作流的顺畅</li>
</ul>
</li>
</ol>
<p>现在，请按照上述执行框架的步骤操作。完成每一步后，请告诉我，我会为您提供详细的说明和指导。</p>
]]></content>
  </entry>
  <entry>
    <title>使用@Override 注解的好处</title>
    <url>/2023/04/19/%E4%BD%BF%E7%94%A8@Override%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    <content><![CDATA[<p>时间：2023-04-11<br>标签： #Java  #注解  #Override</p>
<hr>
<blockquote>
<p>@Override 是可选的，但它有助于验证你没有拼写错误 (或者更微妙地说，大小写字母输入错误)。</p>
</blockquote>
<p>在 Java 编程中，<code>@Override</code> 注解确实是可选的，但它具有一定的好处，可以提高代码的可读性和减少错误。下面列举了几个使用 <code>@Override</code> 注解的优点：</p>
<ol>
<li><p><strong>增强代码可读性</strong>：<br>使用<code>@Override</code>注解表明这个方法是重写父类或实现接口的方法，这使得代码阅读者更容易理解代码的结构和意图。</p>
</li>
<li><p><strong>避免拼写错误和大小写敏感错误</strong>：<br>如果你使用了<code>@Override</code>注解，编译器会检查该方法是否确实重写了父类或接口的方法。这有助于防止因为方法名拼写错误或大小写输入错误而导致的问题。</p>
</li>
<li><p><strong>捕获重构引入的错误</strong>：<br>当父类或接口的方法签名发生变化时，使用<code>@Override</code>注解的子类方法会报编译错误。这有助于开发者在重构过程中捕获到问题，并及时修复错误。</p>
</li>
<li><p><strong>避免意外的方法重载</strong>：<br>在没有使用<code>@Override</code>的情况下，你可能会意外地重载父类的方法，而不是重写它。使用<code>@Override</code>可以确保你的方法确实是重写父类的方法，而不是创建一个新的重载方法。</p>
</li>
</ol>
<p>总结：虽然<code>@Override</code>注解在Java中是可选的，但它可以提高代码的可读性，减少错误，并在重构过程中捕获潜在问题。因此，建议在重写父类或实现接口的方法时，使用<code>@Override</code>注解。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>Override</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo发布博客</title>
    <url>/2023/04/19/%E4%BD%BF%E7%94%A8hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #hexo #github #GitHubPages #shell #blog</p>
<hr>
<p>按照以下步骤将您的 Markdown 文件发布到博客上：</p>
<ol>
<li> <strong>创建新文章</strong>：在 Hexo 项目目录中，运行以下命令以创建一个新的文章文件：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;文章标题&quot;</span><br></pre></td></tr></table></figure>
<p>这将在 <code>source/_posts</code> 目录下创建一个新的 Markdown 文件，您可以用文本编辑器打开它。</p>
<ol start="2">
<li><p> <strong>编辑文章</strong>：将您已经编写好的 Markdown 文件内容复制到新创建的文章文件中。如果需要，您可以在文件顶部的 front matter 中添加或编辑元数据（如标题、日期、标签等）。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;文章标题&quot;</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-04-15</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">标签2</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">文章正文...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p> <strong>生成静态页面</strong>：在项目目录中，运行以下命令以生成静态页面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>这将在 <code>public</code> 文件夹中生成静态网页文件。</p>
</li>
<li><p> <strong>部署到 GitHub Pages</strong>：在 Hexo 项目目录中的 <code>_config.yml</code> 文件中，配置好您的 GitHub Pages 仓库信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/your-username/your-username.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>然后安装 hexo-deployer-git 插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>部署博客：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>这将把生成的静态页面推送到您的 GitHub Pages 仓库。</p>
</li>
<li><p> <strong>查看博客</strong>：访问<code>https://your-username.github.io</code>，您应该能看到更新后的博客。请注意，GitHub Pages可能需要几分钟的时间来部署更新。</p>
</li>
</ol>
<p>完成这些步骤后，您的Markdown文章就会发布到Hexo博客上。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>GitHubPages</tag>
        <tag>shell</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>使用抽象类阻止实例化</title>
    <url>/2023/04/19/%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E9%98%BB%E6%AD%A2%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<p>时间：2023-04-14<br>标签： #Java #abstract类 #设计模式 </p>
<hr>
<blockquote>
<p>可以将一个不包含任何抽象方法的类指明为 abstract，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。<br>——————<br>这是有用的，可是这么做的意义是什么呢，在实际开发过程中，能举个例子么？</p>
</blockquote>
<p>在实际开发过程中，有时候我们希望一个类仅仅作为其他类的基类，而不允许直接创建该类的实例。这种情况下，将这个类声明为抽象类是有意义的。即使这个抽象类没有抽象方法，它仍然不能被实例化，从而确保了这个类仅作为基类存在。</p>
<p>例如，假设我们有一个系统，其中包含各种类型的员工。我们想创建一个通用的基类 <code>Employee</code>，该类包含一些共享的属性和方法，但我们希望用户只能创建具体类型的员工实例（如 <code>Manager</code>、<code>Developer</code> 等），而不是直接创建 <code>Employee</code> 实例。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他共享的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Manager特有的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Developer特有的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们将 <code>Employee</code> 类声明为抽象类，即使它没有抽象方法。这样一来，用户只能创建 <code>Manager</code> 和 <code>Developer</code> 等具体类型的员工实例，而不能直接创建 <code>Employee</code> 实例。这有助于我们在代码中实现更清晰的层次结构和逻辑。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>abstract类</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭airpods的自动链接</title>
    <url>/2023/04/12/%E5%85%B3%E9%97%ADairpods%E7%9A%84%E8%87%AA%E5%8A%A8%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>时间： 2023-04-12<br>标签： #Apple #airpods #airpods #ios #iPadOS #macOS </p>
<hr>
<p>要关闭 AirPods 的自动连接功能，您可以尝试以下步骤：</p>
<ol>
<li> 首先，确保您的 AirPods 已连接到您的设备（iPhone、iPad 或 Mac）。</li>
<li> 对于 iPhone 或 iPad，转到“设置”&gt;“蓝牙”。</li>
<li> 在“我的设备”列表中找到您的 AirPods，然后点击蓝牙列表中 AirPods 名称旁边的小蓝色 “i” 图标。</li>
<li> 在弹出的菜单中，您可以关闭或打开“自动连接”。关闭它将禁用 AirPods 的自动连接功能。</li>
</ol>
]]></content>
      <tags>
        <tag>Apple</tag>
        <tag>airpods</tag>
        <tag>ios</tag>
        <tag>iPadOS</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类-摘录</title>
    <url>/2023/04/19/%E5%86%85%E9%83%A8%E7%B1%BB-%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #java #内部类 </p>
<hr>
<p>设计模式总是将变化的事物与保持不变的事物分离开</p>
<p>既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。</p>
<p>当读者见到这些语言特性的实际应用时，就能最终理解它们了。</p>
<blockquote>
<p>所以说现在阅读完这个章节之后，其预期设置为能够看懂代码的运行机制就可以了。对于如何使用，使用的场景的把握，落在后续在阅读大量代码之后再进行深度体会就好，大可不必于现在，就理解其设计缘由以及对于各种设计模式有所熟练的掌握。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>可变参数（Varargs）在Java中的用法</title>
    <url>/2023/04/19/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%88Varargs%EF%BC%89%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #可变参数 #Varargs #接口 </p>
<hr>
<p>在这个代码片段中，<code>Operations... ops</code> 是一个可变参数（Varargs）的例子。可变参数是 Java 5引入的一个特性，它允许你在方法参数列表中使用零个或多个参数。可变参数类型使用省略号 <code>...</code> 来表示。</p>
<p>在这个示例中，<code>runOps</code>方法接受一个可变参数<code>ops</code>，类型为<code>Operations</code>。这意味着当你调用这个方法时，可以传入零个、一个或多个<code>Operations</code>类型的对象。实际上，Java编译器在内部将这些参数转换为一个数组，因此在<code>runOps</code>方法内部，你可以像操作数组一样操作这些参数。</p>
<p>以下是一个关于如何使用 <code>runOps</code> 方法的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Operations op1 = <span class="keyword">new</span> SomeOperation(); <span class="comment">// 假设SomeOperation实现了Operations接口</span></span><br><span class="line">Operations op2 = <span class="keyword">new</span> AnotherOperation(); <span class="comment">// 假设AnotherOperation实现了Operations接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用runOps方法，传入一个或多个Operations类型的对象</span></span><br><span class="line">Operations.runOps(op1, op2);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了两个实现了<code>Operations</code>接口的对象<code>op1</code>和<code>op2</code>，然后将它们作为参数传递给<code>runOps</code>方法。由于<code>runOps</code>方法接受可变参数，因此我们可以传入任意数量的<code>Operations</code>对象。在<code>runOps</code>方法内部，我们使用增强的for循环（foreach循环）遍历传入的参数，然后调用每个对象的<code>execute()</code>方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>可变参数</tag>
        <tag>Varargs</tag>
      </tags>
  </entry>
  <entry>
    <title>在开发过程中应该如何管理枚举类型数据</title>
    <url>/2023/04/19/%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #枚举类型 </p>
<hr>
<p>在开发过程中，为了保持代码的整洁和可维护性，我们可以采用以下几种方式来管理不同的枚举类型数据：</p>
<ol>
<li>单独创建枚举类文件：将每个枚举类型放在一个单独的 Java 文件中。这种方式可以让枚举类型更容易找到，并有助于代码的组织。例如，对于用户角色，我们可以创建一个名为<code>UserRole.java</code>的文件来存放<code>UserRole</code>枚举。</li>
<li>适当分组：如果有一组密切相关的枚举类型，可以将它们放在一个 Java 文件中。这样可以避免过多的文件数量。例如，我们可以创建一个名为<code>PaymentConstants.java</code>的文件，将<code>PaymentMethod</code>和<code>PaymentStatus</code>等与支付相关的枚举类型放在一起。</li>
<li>使用包来组织：将相关的枚举类型放在同一个包（package）中，可以帮助我们更好地组织代码。例如，将所有与订单管理相关的枚举类型放在<code>com.example.orders.enums</code>包中。</li>
<li>命名规范：为枚举类型选择有意义的名称，以便其他开发人员能够轻松理解它们的用途。同时，遵循项目中的命名规范。通常，枚举类型的名称应该使用驼峰命名法（CamelCase），且每个单词的首字母大写。</li>
<li>文档注释：为每个枚举类型编写文档注释，解释枚举类型的用途和各个值的含义。这可以帮助其他开发人员更容易地理解和使用这些枚举类型。</li>
</ol>
<p>通过以上方法，我们可以更好地管理项目中的枚举类型数据，提高代码的可读性和可维护性。在项目中，我们应该根据业务需求和功能模块来组织枚举类型，而不是简单地将所有枚举类型放在一个包内进行管理。</p>
<p>将枚举类型按照业务进行切分，有以下好处：</p>
<ol>
<li>更好的代码组织：将相关的枚举类型放在同一个包中，可以让代码结构更加清晰，便于开发人员快速找到所需的枚举类型。</li>
<li>提高代码可读性：将枚举类型根据业务需求和功能模块分组，有助于提高代码的可读性，使其他开发人员更容易理解项目的业务逻辑。</li>
<li>便于维护：当需要修改或扩展某个业务功能时，相关的枚举类型都在同一个包中，这样可以更方便地进行修改和维护。</li>
</ol>
<p>因此，在实际项目开发中，我们应该根据业务需求和功能模块来组织枚举类型，以提高代码的可读性、可维护性和易用性。同时，也要遵循项目的整体架构和编码规范，以保持代码的一致性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>枚举类型</tag>
      </tags>
  </entry>
  <entry>
    <title>向上转型的概念</title>
    <url>/2023/04/19/%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #概念 </p>
<hr>
<p>继承图中派生类转型为基类是向上的，所以通常称作==<strong>向上转型</strong>==。因为是从一个更具体的类转化为一个更一般的类，所以向上转型永远是安全的。也就是说，派生类是基类的一个超集。它可能比基类包含更多的方法，但它必须至少具有与基类一样的方法。在向上转型期间，类接口只可能失去方法，不会增加方法。这就是为什么编译器在没有任何明确转型或其他特殊标记的情况下，仍然允许向上转型的原因。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>在 VS Code 中使用 Spring Boot Extension Pack 创建 Spring Boot 项目</title>
    <url>/2023/04/19/%E5%9C%A8%20VS%20Code%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Spring%20Boot%20Extension%20Pack%20%E5%88%9B%E5%BB%BA%20Spring%20Boot%20%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #VSCode #SpringBoot #SpringInitializr #Java #项目创建 #依赖管理 #ExtensionPack</p>
<hr>
<p>以下是使用 VS Code 的 Spring Boot Extension Pack 来创建 Spring Boot 项目的步骤：</p>
<ol>
<li>在 VS Code 中，按下 <code>Ctrl + Shift + P</code>（Mac 下为 <code>Cmd + Shift + P</code>）打开命令面板。</li>
<li>在命令面板中输入 “Spring Initializr”，然后选择 “Spring Initializr: Generate a Maven Project”（或 “Spring Initializr: Generate a Gradle Project”，取决于你喜欢的构建工具）。</li>
<li>选择 “Java” 作为编程语言。</li>
<li>输入 Group ID，这通常是你的公司或项目的域名反转，例如 “com.example”。</li>
<li>输入 Artifact ID，这是你的项目名称，例如 “myproject”。</li>
<li>选择项目打包方式，推荐选择 “Jar”。</li>
<li>选择 Java 版本，推荐使用 “11” 或更高版本。</li>
<li>在依赖列表中，添加所需的依赖，例如：<ul>
<li>  搜索 “web” 并选择 “Spring Web”（用于创建 Web 应用和 RESTful API）。</li>
<li>  搜索 “mysql” 或 “postgresql” 并选择对应的 “MySQL Driver” 或 “PostgreSQL Driver”（根据你的数据库类型选择合适的驱动）。</li>
<li>  搜索 “jpa” 并选择 “Spring Data JPA”（用于实现数据访问层，可选）。</li>
<li>  根据项目需求，添加其他依赖。</li>
</ul>
</li>
<li>点击 “Finish” 生成项目。选择一个文件夹来保存生成的项目。VS Code 将自动解压项目并打开它。</li>
</ol>
<p>至此，你已经使用 VS Code 的 Spring Boot Extension Pack 创建了一个 Spring Boot 项目。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>VSCode</tag>
        <tag>SpringBoot</tag>
        <tag>SpringInitializr</tag>
        <tag>项目创建</tag>
        <tag>依赖管理</tag>
        <tag>ExtensionPack</tag>
      </tags>
  </entry>
  <entry>
    <title>基类子对象的概念和示例</title>
    <url>/2023/04/19/%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>时间：2023-04-11<br>标签： #Java #继承 #基类 #派生类 #子对象</p>
<hr>
<p>基类子对象是指在派生类对象中，与基类对应的部分。当创建一个派生类的对象时，这个对象实际上包含了基类的一个实例，这个实例被称为基类子对象。换句话说，基类子对象是派生类对象中继承自基类的那部分属性和方法。</p>
<p>我们来看一个简单的例子：</p>
<p>```java</p>
<p>// 基类<br>class Animal {<br>    String name;<br>​<br>    public void makeSound() {<br>        System.out.println(“The animal makes a sound”);<br>    }<br>}<br>​<br>// 派生类<br>class Dog extends Animal {<br>    String breed;<br>​<br>    public void bark() {<br>        System.out.println(“The dog barks”);<br>    }<br>}<br>​<br>public class Main {<br>    public static void main(String[] args) {<br>        Dog myDog = new Dog();<br>        myDog.name = “Buddy”;<br>        myDog.breed = “Golden Retriever”;<br>        myDog.makeSound();<br>        myDog.bark();<br>    }<br>}```</p>
<p>在这个例子中，<code>Animal</code>是基类，<code>Dog</code>是派生类。当我们创建一个<code>Dog</code>对象时（<code>Dog myDog = new Dog();</code>），这个对象包含了一个<code>Animal</code>子对象。这个<code>Animal</code>子对象包含了<code>Animal</code>类的属性（如<code>name</code>）和方法（如<code>makeSound()</code>）。</p>
<p>这就是所谓的基类子对象。从外部看，我们在使用<code>Dog</code>对象时，可以直接访问继承自<code>Animal</code>的属性和方法，实际上就是在操作基类子对象。同时，<code>Dog</code>对象还具有派生类特有的属性（如<code>breed</code>）和方法（如<code>bark()</code>）。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>基类</tag>
        <tag>派生类</tag>
        <tag>子对象</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看项目有没有使用spring boot框架</title>
    <url>/2023/04/19/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8spring%20boot%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>时间：2023-04-19<br>标签： #java #spring #SpringBoot </p>
<hr>
<p>要查看项目是否使用了 Spring Boot 框架，可以通过以下方式进行：</p>
<ol>
<li> 查看项目依赖</li>
</ol>
<p>在项目的 pom.xml 文件中查找是否存在 spring-boot-starter-parent 或 spring-boot-starter-web 等 Spring Boot 相关的依赖。这些依赖通常是 Spring Boot 项目所必需的，并且包含了 Spring Boot 相关的配置和功能。</p>
<p>例如，下面是一个 Spring Boot 项目的 pom.xml 文件示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例代码中，可以看到该项目的父依赖为 spring-boot-starter-parent，并且项目依赖了 spring-boot-starter-web，这表明该项目是一个基于 Spring Boot 框架构建的 Web 项目。</p>
<ol start="2">
<li> 查看启动类<br>在项目的源代码中查找是否存在类似于以下代码的启动类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例代码中，使用 <code>@SpringBootApplication</code> 注解标注了 <code>MyApplication</code> 类，并且在 <code>main</code> 方法中调用了 <code>SpringApplication.run</code> 方法启动应用程序。这是 Spring Boot 项目的典型启动方式，因此如果存在类似的启动类，则表明该项目是基于 Spring Boot 框架构建的。</p>
<p>如果以上方式均没有找到 Spring Boot 相关的依赖和启动类，那么该项目可能没有使用 Spring Boot 框架。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>局部内部类的使用</title>
    <url>/2023/04/19/%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #局部内部类</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">if</span>(b) &#123; </span><br><span class="line">			<span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123; </span><br><span class="line">				<span class="keyword">private</span> String id; </span><br><span class="line">				TrackingSlip(String s) &#123; id = s; &#125; </span><br><span class="line">				<span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125; </span><br><span class="line">			&#125; </span><br><span class="line">				TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;slip&quot;</span>); </span><br><span class="line">				String s = ts.getSlip(); </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// Can&#x27;t use it here! Out of scope: </span></span><br><span class="line">		<span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;); </span></span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		internalTracking(<span class="keyword">true</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		Parcel6 p = <span class="keyword">new</span> Parcel6(); p.track(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>——————<br>这么做的意义是什么，直接创建一个 String trackingSlip = “slip”； 不好么</p>
</blockquote>
<p>在这个例子中，<code>Parcel6</code> 类中的 <code>internalTracking</code> 方法使用了一个局部内部类 <code>TrackingSlip</code>。局部内部类是定义在方法中的类，其作用范围仅限于该方法。这样做的目的是将类的实现细节隐藏在方法中，使得类在方法外部无法访问。</p>
<p>局部内部类适用于以下情况：</p>
<ol>
<li>当一个类仅在某个方法中有用，而在方法外部没有任何作用时，可以考虑使用局部内部类。这样可以将实现细节封装在方法内部，提高代码的可读性和维护性。</li>
<li>局部内部类可以访问方法中的局部变量（前提是局部变量需要被声明为<code>final</code>或实际上是<code>final</code>），这使得局部内部类可以与方法的其他部分共享状态。</li>
</ol>
<p>在这个例子中，<code>TrackingSlip</code>类仅在<code>internalTracking</code>方法中有意义，因此将其定义为局部内部类是合理的。这使得<code>TrackingSlip</code>类在方法外部无法访问，从而实现了一种封装。</p>
<p>当然，你提到的直接创建一个<code>String trackingSlip = &quot;slip&quot;;</code>也是一种解决方案，但这个例子主要是为了展示局部内部类的概念和使用方法。在实际开发中，如果局部内部类的功能可以简单地用一个变量或简单的方法来实现，那么采用更简单的方案通常是更好的选择。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>局部内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端程序员概念</title>
    <url>/2023/04/19/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #客户端程序员 #Java </p>
<hr>
<p>“客户端程序员”指的是那些使用你编写的类、库或框架的其他程序员。在这个上下文中，”客户端”并不是指一个运行在用户设备上的应用程序，而是指那些依赖于你提供的代码的其他程序员或他们编写的代码。</p>
<p>当你创建一个类、库或框架时，你可能会为其他程序员提供一组 API（应用程序编程接口），以便他们能够轻松地使用你的代码来实现特定功能。客户端程序员会基于你提供的 API 编写他们自己的代码，而不需要了解你代码的内部实现细节。这种封装和分离有助于提高代码的可维护性和可扩展性。</p>
<p>例如，假设你编写了一个名为 MyMathLibrary 的数学库，它包含一些有用的数学函数（如加法、减法、乘法等）。客户端程序员（在这种情况下，可能是其他软件开发人员）将使用你提供的 MyMathLibrary API 来调用这些函数，而不需要了解这些函数的具体实现。这样，他们可以专注于自己的应用程序逻辑，而不必担心底层的数学操作。</p>
<p>因此，当我们在之前的回答中讨论客户端程序员时，我们是指那些使用你提供的类、库或框架的其他程序员，他们需要依赖于你提供的 API 来实现他们的需求。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>客户端程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类的目的和作用</title>
    <url>/2023/04/19/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #抽象类 #面向对象 #封装 #设计原则</p>
<hr>
<blockquote>
<p>一定程度上，我们声明一个类为抽象类，是为了防止客户端程序员对这个类进行实例化的一种防范手段。除此之外，还有别的使用抽象类的目的么？</p>
</blockquote>
<p>将一个类声明为抽象类可以阻止客户端程序员直接实例化这个类。这样做的目的是表明这个类只能作为其他类的基类，而不能直接使用。此外，抽象类还有以下作用：</p>
<ol>
<li><strong>提供共享实现</strong>：抽象类可以包含一些共享的状态（属性）和方法实现，这些代码可以被子类继承和复用。这样，我们可以把一些通用的功能放在抽象类中，减少重复代码，提高代码的可维护性。</li>
<li><strong>定义接口规范</strong>：抽象类可以包含抽象方法，这些方法定义了子类应该实现的接口规范。通过抽象方法，我们可以明确地表示子类需要实现哪些方法，以满足特定的功能需求。</li>
<li><strong>实现多态</strong>：抽象类可以作为一种多态机制的实现手段。通过让子类重写抽象类中的方法，我们可以在运行时通过抽象类引用实际的子类对象，实现动态绑定和多态行为。</li>
<li><strong>模板方法模式</strong>：抽象类可以实现模板方法模式，这是一种行为设计模式。在这种模式中，抽象类定义了一个算法的框架，将一些具体的实现步骤延迟到子类中。这样，子类可以在不改变算法结构的情况下，重定义某些特定的实现步骤。</li>
</ol>
<p>总之，抽象类除了防止直接实例化之外，还有很多其他作用。它可以用于提供共享实现、定义接口规范、实现多态以及实现模板方法模式等。在设计类结构时，我们可以根据实际需求选择使用抽象类。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计原则</tag>
        <tag>抽象类</tag>
        <tag>封装</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类型（Enumerate）的实际应用</title>
    <url>/2023/04/19/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%88Enumerate%EF%BC%89%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #枚举类型 </p>
<hr>
<p>在日常的 Java 生产工作中，枚举类型（Enum）确实会被广泛应用。枚举类型能够提供一组固定的值集合，它们在编译时就已经确定。使用枚举类型可以增强代码的可读性和健壮性，因为它可以限制变量的取值范围。</p>
<p>以下是一个具体的业务场景示例：</p>
<p>假设我们正在为一个在线购物网站开发一个订单管理系统。在系统中，我们需要处理不同状态的订单，例如已提交、已支付、已发货、已完成、已取消等。这时候，我们可以使用枚举类型来表示订单的各种状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OrderStatus</span> </span>&#123;     </span><br><span class="line">	SUBMITTED, <span class="comment">// 已提交     </span></span><br><span class="line">	PAID,      <span class="comment">// 已支付     </span></span><br><span class="line">	SHIPPED,   <span class="comment">// 已发货     </span></span><br><span class="line">	COMPLETED, <span class="comment">// 已完成     </span></span><br><span class="line">	CANCELED   <span class="comment">// 已取消 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在订单类（Order）中，我们可以使用这个枚举类型来表示订单的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;     </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> id;     </span><br><span class="line">	<span class="keyword">private</span> List&lt;OrderItem&gt; items;     </span><br><span class="line">	<span class="keyword">private</span> Date createdAt;     </span><br><span class="line">	<span class="keyword">private</span> OrderStatus status;      </span><br><span class="line">	<span class="comment">// 构造方法、getter 和 setter 方法等 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了枚举类型，我们就能在代码中清晰地表达订单状态的变化，同时也限制了订单状态的取值范围，降低了出错的可能性。例如，当一个订单被支付后，我们可以将其状态更改为已支付：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order order = <span class="keyword">new</span> Order(); </span><br><span class="line">order.setStatus(OrderStatus.SUBMITTED); <span class="comment">// ... 其他操作 ...</span></span><br><span class="line">order.setStatus(OrderStatus.PAID);</span><br></pre></td></tr></table></figure>

<p>总之，枚举类型在日常的 Java 生产工作中非常有用，可以帮助我们编写更可读、更健壮的代码。</p>
<p>当然，还有很多其他业务场景可以使用枚举类型。下面是几个典型的例子：</p>
<ol>
<li> 用户角色管理：</li>
</ol>
<p>在很多应用系统中，我们需要对用户的角色进行管理，例如普通用户、管理员、超级管理员等。我们可以使用枚举类型来表示不同的用户角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserRole</span> </span>&#123;</span><br><span class="line">    REGULAR_USER,  <span class="comment">// 普通用户</span></span><br><span class="line">    ADMIN,         <span class="comment">// 管理员</span></span><br><span class="line">    SUPER_ADMIN    <span class="comment">// 超级管理员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 周几表示：</li>
</ol>
<p>在处理日期和时间的应用程序中，我们可能需要表示一周中的某一天，可以使用枚举类型来表示周几：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DayOfWeek</span> </span>&#123;</span><br><span class="line">    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li> 颜色表示：</li>
</ol>
<p>在处理颜色相关的应用程序中，我们可能需要表示一些基本的颜色，可以使用枚举类型表示这些颜色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, WHITE, BLACK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li> 支付方式表示：</li>
</ol>
<p>在处理支付相关的应用程序中，我们可能需要表示不同的支付方式，例如信用卡、支付宝、微信支付等。可以使用枚举类型表示这些支付方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PaymentMethod</span> </span>&#123;</span><br><span class="line">    CREDIT_CARD, ALIPAY, WECHAT_PAY, PAYPAL, BANK_TRANSFER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>枚举类型</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Java 中的 hashCode() 方法以及与 toString() 和 equals() 方法的关系</title>
    <url>/2023/04/19/%E7%90%86%E8%A7%A3%20Java%20%E4%B8%AD%E7%9A%84%20hashCode()%20%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%B8%8E%20toString()%20%E5%92%8C%20equals()%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #hashCode #equals #toString #对象比较  #散列数据结构</p>
<hr>
<blockquote>
<p>hashCode() 为什么会和 toString equals 方法放在一起，它也很常被重写么，为什么，它的作用是什么</p>
</blockquote>
<p><code>hashCode()</code> 方法与 <code>toString()</code> 和 <code>equals()</code> 方法经常放在一起，因为它们都是 Java 中 <code>Object</code> 类的公共方法，通常需要根据实际需求在子类中重写。当您创建自定义类时，重写这些方法可以帮助您更好地处理对象之间的比较、散列存储和调试。</p>
<p><code>hashCode()</code> 的主要作用是为对象提供一个散列值。这个散列值通常用于散列数据结构（例如 <code>HashMap</code>、<code>HashSet</code>）中，以提高数据存储和检索的性能。当您将对象作为散列数据结构的键时，<code>hashCode()</code> 方法就显得非常重要。</p>
<p><code>hashCode()</code> 应该遵循以下约定：</p>
<ol>
<li> 在同一个 Java 应用程序执行期间，对同一个对象多次调用 <code>hashCode()</code> 应该返回相同的值。</li>
<li> 如果两个对象根据 <code>equals()</code> 方法相等，那么它们的 <code>hashCode()</code> 应该相等。</li>
<li> 如果两个对象根据 <code>equals()</code> 方法不相等，它们的 <code>hashCode()</code> 不一定要不同。但是，具有不同散列值的对象可能会提高散列数据结构的性能。</li>
</ol>
<p>因此，当您重写 <code>equals()</code> 方法时，通常也需要重写 <code>hashCode()</code> 方法，以确保它们的行为一致。这有助于确保您的自定义类在散列数据结构中表现良好。这也是为什么 <code>hashCode()</code> 与 <code>toString()</code> 和 <code>equals()</code> 方法经常放在一起讨论的原因。</p>
<p>以下是一个简单的示例，说明如何重写 <code>hashCode()</code> 和 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、getter 和 setter 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span> || getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们根据 <code>Person</code> 类的 <code>name</code> 和 <code>age</code> 属性重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法。这样，当我们将 <code>Person</code> 对象作为 <code>HashMap</code> 或 <code>HashSet</code> 的键时，它们将根据 <code>name</code> 和 <code>age</code> 属性正确地进行比较和散列。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>hashCode</tag>
        <tag>equals</tag>
        <tag>toString</tag>
        <tag>对象比较</tag>
        <tag>散列数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>组合和继承的选择</title>
    <url>/2023/04/19/%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #继承 #组合 </p>
<hr>
<p>在面向对象编程中，创建和使用代码最有可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。继承其实不太常用。因此尽管在教授 OOP 的过程中我们多次强调继承，但这并不意味着要尽可能使用它。</p>
<p><strong>恰恰相反</strong>，==尽量少使用它（继承）==，除非确实使用继承是有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>继承</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>访问说明符</title>
    <url>/2023/04/19/%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #java #访问说明符</p>
<hr>
<p>访问说明符（Access Modifiers）是Java中用于设置类、方法或属性访问级别的关键字。它们决定了其他类或对象如何访问特定类、方法或属性。Java中有四种访问说明符：</p>
<ol>
<li><code>public</code>：公共访问级别，表示类、方法或属性对所有其他类都是可见的和可访问的。任何类都可以访问public成员。</li>
<li><code>protected</code>：受保护访问级别，表示类、方法或属性对同一个包（package）中的其他类和所有子类是可见的和可访问的。这意味着，只有在相同包中的类和继承了此类的子类可以访问protected成员。</li>
<li><code>private</code>：私有访问级别，表示类、方法或属性只能被其所在类访问。私有成员不能被其他类访问，也不能被子类访问。</li>
<li>默认（没有访问说明符，也称为“包访问级别”或“友元访问级别”）：当不使用任何访问说明符时，类、方法或属性对同一个包（package）中的其他类是可见的和可访问的。这意味着，只有在相同包中的类可以访问默认成员。</li>
</ol>
<p>访问说明符使得开发人员能够在类的设计中明确地定义哪些部分可以被其他类访问，哪些部分应该对外部隐藏。这有助于实现封装和信息隐藏，是面向对象编程的重要原则。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>访问说明符</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历map</title>
    <url>/2023/04/19/%E9%81%8D%E5%8E%86map/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #map </p>
<hr>
<p>在 Java 中，遍历 Map 的方式有很多，以下是常见的三种方法：</p>
<p>方法一：使用 keySet()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = ...; <span class="comment">// 假设这是你的Map</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：使用 entrySet()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = ...; <span class="comment">// 假设这是你的Map</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：使用 Java 8 的 forEach() 和 Lambda 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = ...; <span class="comment">// 假设这是你的Map</span></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure>
<p>以上是遍历 Map 的三种常见方法，你可以根据实际情况选择合适的方法。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类的目的以及由来</title>
    <url>/2023/04/19/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E4%BB%A5%E5%8F%8A%E7%94%B1%E6%9D%A5/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #java #抽象类 #由来</p>
<hr>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>一种介于普通类和接口之间的折中手段</p>
<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><p>对于像 <strong>Instrument</strong> 那样的抽象类来说，它的对象几乎总是没有意义的。创建一个抽象类是为了通过通用接口操纵一系列类。因此，<strong>Instrument</strong> 只是表示接口，不是具体实现，所以创建一个 <strong>Instrument</strong> 的对象毫无意义，我们可能希望阻止用户这么做。通过让 <strong>Instrument</strong> 所有的方法产生错误，就可以达到这个目的，但是这么做会延迟到运行时才能得知错误信息，并且需要用户进行可靠、详尽的测试。最好能在编译时捕捉问题。</p>
]]></content>
      <tags>
        <tag>抽象类</tag>
        <tag>java</tag>
        <tag>由来</tag>
      </tags>
  </entry>
  <entry>
    <title>避免接口组合时的方法名冲突</title>
    <url>/2023/04/19/%E9%81%BF%E5%85%8D%E6%8E%A5%E5%8F%A3%E7%BB%84%E5%90%88%E6%97%B6%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>时间：2023-04-18<br>标签： #Java #接口 #命名规范 #代码可读性</p>
<hr>
<p>避免接口组合时方法名冲突的方法有以下几种：</p>
<ol>
<li><strong>明确命名</strong>：确保接口方法的命名清晰明了，尽量表达出方法的作用和所属领域。这样可以减少不同接口中方法名相同的可能性。</li>
<li><strong>接口分层</strong>：根据功能或领域对接口进行分层。将通用的方法放在基本接口中，然后让更具体的接口继承这些基本接口。这样可以减少方法名冲突的可能性，同时提高代码的可读性和可维护性。</li>
<li><strong>限制接口的大小</strong>：遵循接口隔离原则，确保每个接口都具有明确的职责。避免在一个接口中包含过多的方法。这样可以降低不同接口之间方法名冲突的风险。</li>
<li><strong>遵循命名约定</strong>：在团队中制定并遵循一致的命名规范，例如在方法名前加上接口名称的缩写，以区分不同接口中的方法。这样可以降低方法名冲突的可能性，并提高代码的可读性。</li>
<li><strong>使用Java 8的默认方法</strong>：如果多个接口中有相同的方法名，但实现逻辑相同，可以使用Java 8引入的默认方法特性，在接口中提供默认实现。这样可以避免重复代码，同时消除方法名冲突带来的困扰。</li>
</ol>
<p>通过采用这些策略，可以在很大程度上避免接口组合时方法名冲突，提高代码的可读性和可维护性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>命名规范</tag>
        <tag>代码可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>默认包访问权限的正确分词</title>
    <url>/2023/04/19/%E9%BB%98%E8%AE%A4%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%88%86%E8%AF%8D/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #Java #概念</p>
<hr>
<p>“默认包访问权限”应该分词为”默认”和”包访问权限”。在 Java 中，如果没有为类或类的成员指定访问修饰符（如 public、private、protected），那么它们将具有默认的包访问权限。这意味着这些成员只能被同一个包中的其他类访问，而不能被其他包中的类访问。这种访问级别在某些情况下可以为隐藏类的实现细节提供足够的保护。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云购买域名绑定 GitHub 个人主页</title>
    <url>/2023/04/19/%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%20GitHub%20%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/</url>
    <content><![CDATA[<p>时间：2023-04-12<br>标签： #阿里云 #GitHub #个人主页 #域名 </p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>在阿里云配置 DNS 记录：<br>    1. 登录到阿里云控制台。<br>    2. 转到【域名与网站】&gt;【域名管理】。<br>    3. 找到您的域名并点击【解析设置】。<br>    4. 添加以下两条 A 记录：<br>        - 主机记录：@<br>        - 记录类型：A<br>        - 记录值：185.199.108.153<br>        - TTL：根据您的需求设置，建议设置为 600（10 分钟）。<br>        - 添加第二条 A 记录，重复上述步骤，但将记录值更改为 185.199.109.153。<br>        - 添加第三条 A 记录，重复上述步骤，但将记录值更改为 185.199.110.153。<br>        - 添加第四条 A 记录，重复上述步骤，但将记录值更改为 185.199.111.153。<br>    5. 如果您希望使用 www 子域名 ，例如 <a href="http://www.example.com/">www.example.com</a> ，则需要添加一条 CNAME 记录：<br>        - 主机记录：www<br>        - 记录类型：CNAME<br>        - 记录值：用户名. Github. Io（将用户名替换为您的 GitHub 用户名）<br>        - TTL：根据您的需求设置，建议设置为 600（10 分钟）。</p>
<p>等待 DNS 解析生效。这可能需要一些时间，通常在几分钟到几小时之间，最多可能需要 48 小时。</p>
<p>完成这些步骤后，您的域名应该会成功指向您的 GitHub 个人主页。</p>
<p>如果在完成上述步骤后仍无法访问您的域名，请检查您的设置或等待 DNS 解析生效。</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><h2 id="A-这些记录值是在做什么"><a href="#A-这些记录值是在做什么" class="headerlink" title="A. 这些记录值是在做什么"></a>A. 这些记录值是在做什么</h2><p>这里的记录值是 DNS 记录的一部分。在这个过程中，我们添加了 A 记录和 CNAME 记录。下面是这些记录值的解释：</p>
<ol>
<li> A 记录（地址记录）：</li>
</ol>
<p>A 记录用于将域名解析到一个 IPv4 地址。在这个例子中，我们添加了四个 A 记录，每个记录值是 GitHub Pages 的服务器 IP 地址：</p>
<ul>
<li>  185.199.108.153</li>
<li>  185.199.109.153</li>
<li>  185.199.110.153</li>
<li>  185.199.111.153</li>
</ul>
<p>当用户访问您的域名时（例如：<code>example.com</code>），DNS 服务器会查找与该域名关联的 IP 地址。通过设置这些 A 记录，您告诉 DNS 服务器，您的域名应该解析到这四个 GitHub Pages 服务器中的一个。这样，当用户访问您的域名时，他们将被引导到托管在 GitHub Pages 上的网站。</p>
<ol start="2">
<li> CNAME 记录（规范名称记录）：</li>
</ol>
<p>CNAME 记录用于将一个域名（通常是子域名）映射到另一个域名。在这个例子中，我们添加了一个 CNAME 记录，将 <code>www</code> 子域名（如：<code>www.example.com</code>）映射到您的 GitHub Pages 个人主页域名（如：<code>用户名.github.io</code>，将 <code>用户名</code> 替换为您的 GitHub 用户名）。</p>
<p>添加这个 CNAME 记录后，当用户访问 <code>www.example.com</code> 时，他们将被引导到与 <code>用户名.github.io</code> 关联的相同 GitHub Pages 网站。这样可以确保用户在访问 <code>example.com</code> 和 <code>www.example.com</code> 时看到的内容是一致的。</p>
<p>总之，这些记录值用于指导 DNS 解析过程，将您的自定义域名解析到托管在 GitHub Pages 上的网站。这样，无论用户访问您的裸域名（如：<code>example.com</code>）还是带有 <code>www</code> 子域名的版本（如：<code>www.example.com</code>），他们都会看到您的 GitHub 个人主页。</p>
<h2 id="B-如果域名解析还是存在问题"><a href="#B-如果域名解析还是存在问题" class="headerlink" title="B. 如果域名解析还是存在问题"></a>B. 如果域名解析还是存在问题</h2><p>如果您的域名解析仍然存在问题，您可以尝试以下几种方法：</p>
<ol>
<li>检查您的 DNS 设置是否正确：<ul>
<li>  确保您在阿里云的域名管理中已经添加了正确的 A 记录和 CNAME 记录。</li>
<li>  确保您在 GitHub 仓库中添加了正确的 CNAME 文件，内容应为您的自定义域名。</li>
<li>如果您在设置过程中更改了任何设置，请确保保存更改。</li>
</ul>
</li>
<li>等待 DNS 解析生效：<ul>
<li>  请耐心等待，因为 DNS 解析可能需要一段时间（从几分钟到 48 小时）。</li>
<li>您可以使用在线 DNS 查询工具（如 Google Public DNS 或其他第三方工具）来检查您的域名解析状态。</li>
</ul>
</li>
<li>清除浏览器缓存和 DNS 缓存：<ul>
<li>  清除浏览器缓存以确保您查看的是最新版本的网站。</li>
<li>  如果您使用的是 Windows，可以尝试通过命令提示符运行 <code>ipconfig /flushdns</code> 命令来清除 DNS 缓存。</li>
<li>  对于 macOS，您可以使用 <code>sudo killall -HUP mDNSResponder</code> 命令来清除 DNS 缓存。</li>
<li>在 Linux 上，您可以使用 <code>sudo systemctl restart nscd</code> 或 <code>sudo /etc/init.d/nscd restart</code> 命令清除 DNS 缓存。</li>
</ul>
</li>
<li>检查防火墙或安全设置：<ul>
<li>某些防火墙或安全设置可能会阻止域名解析。请检查您的防火墙或安全设置，以确保它们没有阻止您的域名解析。</li>
</ul>
</li>
<li>寻求技术支持：<ul>
<li>  如果问题仍然存在，请联系阿里云和 GitHub Pages 的技术支持，他们可以帮助您进一步诊断问题。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>阿里云</tag>
        <tag>GitHub</tag>
        <tag>个人主页</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>CharSequence 与 String 的区别及作用</title>
    <url>/2023/04/28/CharSequence%20%E4%B8%8E%20String%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-28<br>标签： #Java #CharSequence #String</p>
<hr>
<p><strong>CharSequence：</strong></p>
<p>CharSequence 是一个接口，它定义了一系列字符的通用只读访问方法。CharSequence 提供了对字符序列进行操作的统一接口，使得代码更具有通用性。Java 中的很多类实现了 CharSequence 接口，例如 String、StringBuilder 和 StringBuffer 等。</p>
<p>主要作用：CharSequence 接口的主要作用是为不同类型的字符序列提供一个统一的访问方式，便于编写更具有通用性的代码。</p>
<p><strong>String：</strong></p>
<p>String 是一个类，代表不可变的字符序列。当一个 String 对象被创建后，它的内容是不可更改的。由于 String 的不可变性，它在 Java 中被广泛用作字符串处理的基本类型。</p>
<p>主要作用：String 类的主要作用是表示和处理不可变的字符序列，例如存储文本、拼接字符串、查找子字符串等。</p>
<p><strong>区别：</strong></p>
<ol>
<li>CharSequence 是一个接口，而 String 是一个实现了 CharSequence 接口的具体类。</li>
<li>CharSequence 接口定义了通用的只读字符序列访问方法，而 String 类提供了更多具体的操作方法，例如字符串拼接、替换、查找等。</li>
<li>String 对象的内容是不可变的，而其他实现 CharSequence 接口的类（如 StringBuilder 和 StringBuffer）的内容是可变的。</li>
</ol>
<p><strong>举例说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharSequenceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLength</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符序列长度: &quot;</span> + cs.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用统一的CharSequence接口处理不同类型的字符序列</span></span><br><span class="line">        printLength(string); <span class="comment">// 输出：字符序列长度: 13</span></span><br><span class="line">        printLength(stringBuilder); <span class="comment">// 输出：字符序列长度: 13</span></span><br><span class="line">        printLength(stringBuffer); <span class="comment">// 输出：字符序列长度: 13</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个 <code>printLength</code> 方法，它接收一个 CharSequence 参数并打印其长度。我们创建了一个 String 对象、一个 StringBuilder 对象和一个 StringBuffer 对象，然后分别传入 <code>printLength</code> 方法。由于这三个对象都实现了 CharSequence 接口，我们可以使用统一的方法处理它们。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>CharSequence</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection与 List 接口的关系</title>
    <url>/2023/04/28/Collection%E4%B8%8E%20List%20%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>时间：2023-04-25<br>标签： #Java #Collection #List </p>
<hr>
<ol>
<li><p>集合框架层次结构</p>
<ul>
<li>Java 集合框架 (Collections Framework) 是 Java 标准库的一部分，提供了一套用于存储和操作数据集合的接口和实现类。</li>
<li>Collection 接口是 Java 集合框架的基础接口，所有的集合类都实现了这个接口。</li>
<li>List、Set 和 Queue 都是 Collection 的子接口，它们提供了各自特定的数据存储和操作方法。</li>
</ul>
</li>
<li><p>Collection 接口</p>
<ul>
<li>Collection 接口是集合框架的根接口，定义了一组通用的集合操作方法，如 add ()、remove ()、contains ()、isEmpty ()、size ()、iterator () 等。</li>
<li>Collection 接口不提供具体的数据结构，而是通过它的子接口和实现类来实现各种数据结构，如 List、Set、Queue 等。</li>
</ul>
</li>
<li><p>List 接口</p>
<ul>
<li>List 接口是一个有序集合，允许存储重复的元素。</li>
<li>List 接口继承了 Collection 接口，所以它具有 Collection 接口的所有通用方法。</li>
<li>List 接口还提供了一些额外的方法，用于操作有序集合，如 get ()、set ()、indexOf ()、lastIndexOf ()、subList () 等。</li>
<li>List 接口的实现类有 ArrayList、LinkedList、Vector 和 Stack 等。</li>
</ul>
</li>
<li><p>Collection 与 List 的关系</p>
<ul>
<li>List 接口是 Collection 接口的一个子接口，它继承了 Collection 提供的通用方法。</li>
<li>List 接口添加了额外的方法，用于操作有序集合，这些方法使得 List 更适合于有序集合的场景。</li>
<li>通过实现 List 接口，具体的实现类如 ArrayList、LinkedList 等能够同时具备通用集合操作和有序集合操作的特性。</li>
</ul>
</li>
</ol>
<p>总结：Collection 接口是 Java 集合框架的基础接口，定义了一组通用的集合操作方法。List 接口是 Collection 的子接口，它继承了 Collection 的方法，并添加了额外的方法以支持有序集合的操作。具体的实现类如 ArrayList、LinkedList 等实现了 List 接口，从而具备了通用集合操作和有序集合操作的特性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中异常的作用及与 if 条件判断的区别</title>
    <url>/2023/04/28/Java%20%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%B8%8E%20if%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>时间：2023-04-28<br>标签： #Java #异常处理 #if条件判断</p>
<hr>
<p><strong>异常的作用：</strong></p>
<ol>
<li>提示错误：异常是 Java 中一种用于表示错误或意外情况的机制。当程序执行过程中遇到错误时，Java 会抛出一个异常，以提示开发者程序中存在问题。</li>
<li>分离错误处理代码：异常处理允许将错误处理代码与正常执行代码分离，使代码更加清晰和易于维护。</li>
<li>提高程序的健壮性：通过使用异常处理机制，程序在遇到错误时可以进行适当的处理（如记录日志、释放资源等），而不是立即崩溃，从而提高程序的健壮性。</li>
</ol>
<p><strong>为什么不仅使用 if 条件判断：</strong></p>
<ol>
<li>可读性：当错误情况较多时，使用 if 条件判断会导致代码变得复杂和难以阅读。异常处理可以将错误处理逻辑与正常执行逻辑分离，提高代码的可读性。</li>
<li>传递错误信息：异常对象包含了关于错误的详细信息（如异常类型、错误消息等），这些信息在异常处理过程中可以被捕获和传递。而使用 if 条件判断往往难以传递丰富的错误信息。</li>
<li>统一处理：异常处理机制允许在方法调用栈的更高层次统一处理异常，而不需要在每个方法中都使用 if 条件判断处理错误。</li>
</ol>
<p><strong>异常处理与 if 条件判断的区别：</strong></p>
<ol>
<li>异常处理用于处理程序运行过程中的错误和异常情况，而 if 条件判断用于处理程序正常执行过程中的逻辑分支。</li>
<li>异常处理可以将错误处理逻辑与正常执行逻辑分离，而 if 条件判断将错误处理逻辑和正常执行逻辑混合在一起。</li>
<li>异常处理可以在方法调用栈的更高层次统一处理异常，而 if 条件判断通常需要在每个方法中分别处理错误。</li>
<li>异常对象包含了丰富的错误信息，而 if 条件判断通常只能根据条件判断结果进行处理。</li>
</ol>
<p>总之，异常处理与 if 条件判断在处理错误和异常情况时具有不同的特点和优势。在适当的场景下，结合使用异常处理和 if 条件判断可以更好地提高程序的可读性、健壮性和易维护性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>异常处理</tag>
        <tag>if条件判断</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的 NIO</title>
    <url>/2023/04/28/Java%20%E4%B8%AD%E7%9A%84%20NIO/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #NIO #非阻塞IO</p>
<hr>
<p>在 Java 中，NIO 是“Non-blocking Input/Output”的缩写，意为非阻塞输入输出。NIO 是 Java 的一个 I/O（输入输出）框架，提供了与传统 I/O 不同的处理数据的方式。从 Java 1.4 开始引入 NIO，主要目的是提高数据传输的性能，降低系统资源占用，并提供更灵活的 I/O 操作。</p>
<p>NIO 的主要特点和优势包括：</p>
<ol>
<li><p>非阻塞模式：</p>
<ul>
<li>传统的 Java I/O 是阻塞式的，即在读取或写入数据时，线程会被阻塞，直到操作完成。而 NIO 支持非阻塞模式，在执行 I/O 操作时，线程可以继续处理其他任务，从而提高程序的并发性能。</li>
</ul>
</li>
<li><p>缓冲区和通道：</p>
<ul>
<li>NIO 引入了缓冲区（Buffer）和通道（Channel）的概念。缓冲区用于暂存数据，通道用于在缓冲区和数据源（如文件或网络连接）之间传输数据。这种设计可以有效地管理数据传输，提高数据处理的性能。</li>
</ul>
</li>
<li><p>选择器：</p>
<ul>
<li>NIO 提供了选择器（Selector）的概念，它允许单个线程处理多个通道的事件。这意味着，使用 NIO 可以用较少的线程处理大量的 I/O 操作，从而降低系统资源占用。</li>
</ul>
</li>
</ol>
<p>在 <code>java.nio.file</code> 包中，主要包含了与文件系统相关的 NIO 功能，如文件操作、目录监控和文件属性等。这些功能允许你使用 NIO 的特性来处理文件系统相关的任务，提高文件操作的性能和灵活性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
        <tag>非阻塞IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的流（Stream）操作简介</title>
    <url>/2023/04/28/Java%20%E4%B8%AD%E7%9A%84%E6%B5%81%EF%BC%88Stream%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #Stream #函数式编程</p>
<hr>
<p>Java 8 引入了流（Stream）操作，这是一种新的抽象，允许对集合进行高效、声明式的处理。流操作主要用于对集合进行各种转换、过滤、排序等操作，使得处理数据更加简洁、易读。</p>
<p>流（Stream）的核心特点如下：</p>
<ol>
<li><p>声明式编程：流操作使用声明式编程风格，这使得您可以表达想要完成的任务，而不需要指定如何执行任务的详细步骤。</p>
</li>
<li><p>无状态：流操作是无状态的，这意味着流操作不会修改底层数据结构。相反，它们通过生成新的结果来处理数据。</p>
</li>
<li><p>懒加载：流操作支持懒加载，这意味着操作仅在需要结果时才会执行，从而提高性能。</p>
</li>
<li><p>并行化：流操作可以自动并行化处理，这使得在多核处理器上处理大量数据更加高效。</p>
</li>
</ol>
<p>流操作主要分为两类：</p>
<ol>
<li><p>中间操作（Intermediate Operations）：这些操作在 Stream 上执行，返回一个新的 Stream。这些操作是惰性的，只有在终止操作被调用时才会执行。例如：filter、map、flatMap 等。</p>
</li>
<li><p>终止操作（Terminal Operations）：这些操作会终止 Stream 并生成结果。当终止操作被调用时，所有的中间操作会一次性执行。例如：collect、reduce、forEach、sum 等。</p>
</li>
</ol>
<p>以下是一个简单的 Stream 操作示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cathy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Stream 操作过滤、转换和排序名字列表</span></span><br><span class="line">List&lt;String&gt; sortedNames = names.stream()</span><br><span class="line">    .filter(name -&gt; name.length() &gt; <span class="number">3</span>)      <span class="comment">// 过滤长度大于 3 的名字</span></span><br><span class="line">    .map(String::toUpperCase)               <span class="comment">// 将名字转换为大写</span></span><br><span class="line">    .sorted()                               <span class="comment">// 对名字进行排序</span></span><br><span class="line">    .collect(Collectors.toList());          <span class="comment">// 将结果收集为一个新的列表</span></span><br><span class="line"></span><br><span class="line">System.out.println(sortedNames);           <span class="comment">// 输出：[ALICE, CATHY]</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用流操作对名字列表进行过滤、转换和排序。使用 Stream API，我们可以以一种更加声明式、易读的方式完成这些操作。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 迭代器的单向移动原因</title>
    <url>/2023/04/28/Java%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8D%95%E5%90%91%E7%A7%BB%E5%8A%A8%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #迭代器 #Iterator #单向移动</p>
<hr>
<p>Java 的迭代器（Iterator）设计为只能单向移动的原因主要有以下几点：</p>
<ol>
<li><p>简化实现：</p>
<ul>
<li>设计迭代器为单向移动可以简化实现，避免反向遍历带来的复杂性。这有助于保持迭代器的轻量级特性，降低内存占用和性能开销。</li>
</ul>
</li>
<li><p>适用于更多场景：</p>
<ul>
<li>单向移动的迭代器适用于各种集合，包括链表、数组、树等。反向遍历在某些数据结构（如单向链表）上实现起来较为复杂，因此单向移动的迭代器具有更广泛的适用性。</li>
</ul>
</li>
<li><p>降低使用复杂度：</p>
<ul>
<li>单向移动的迭代器在使用时更加直观和简单，用户不需要处理双向移动带来的额外逻辑。这有助于提高代码的可读性和易用性。</li>
</ul>
</li>
</ol>
<p>尽管 Java 的迭代器（Iterator）只能单向移动，但 Java 提供了另一个名为 ListIterator 的接口，它支持在列表上的双向遍历。ListIterator 继承自 Iterator 接口，添加了向前移动、获取当前索引等方法。当需要双向遍历时，可以考虑使用 ListIterator 接口。不过，ListIterator 仅适用于列表类型的集合，如 ArrayList 和 LinkedList。</p>
<p>总之，Java 的 Iterator 设计为单向移动，主要是为了简化实现、适用于更多场景以及降低使用复杂度。在需要双向遍历的场景中，可以考虑使用 ListIterator 接口。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>迭代器</tag>
        <tag>Iterator</tag>
        <tag>单向移动</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式简介</title>
    <url>/2023/04/28/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #Lambda表达式 #函数式编程</p>
<hr>
<p>Lambda 表达式（Lambda Expression）是 Java 8 引入的一种新的编程构造，用于表示一种简洁、匿名的函数表达式。它允许您将函数（方法）作为参数传递给其他方法，或者作为返回值。Lambda 表达式在函数式编程中尤为重要，因为它们提供了一种更简洁、易读的方式来表示代码中的行为。</p>
<p>关于 Lambda 的名字来源于计算机科学中的 Lambda 演算（Lambda Calculus），这是一种数学形式化系统，用于研究函数抽象、函数应用等概念。Lambda 演算在计算机科学中具有重要地位，因为它为理解编程语言的基本结构和原理提供了理论基础。</p>
<p>在 Java 中，Lambda 表达式的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>parameters</code>：表示输入参数列表，可以是零个、一个或多个参数。如果只有一个参数，可以省略括号。</li>
<li><code>-&gt;</code>：箭头符号，表示将参数传递给函数体。</li>
<li><code>body</code>：表示函数体，包含执行的代码。如果函数体只有一条语句，可以省略大括号。</li>
</ul>
<p>Lambda 表达式的一个典型应用场景是 Java 中的函数式接口。函数式接口是只包含一个抽象方法的接口，如 Runnable、Comparator 和 Callable 等。使用 Lambda 表达式，可以简洁地表示这些接口的实现，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里，Lambda 表达式 <code>() -&gt; System.out.println(&quot;Hello, Lambda!&quot;);</code> 表示一个没有参数且没有返回值的函数，实现了 Runnable 接口的 <code>run</code> 方法。使用 Lambda 表达式可以使代码更简洁、易读，尤其是在处理集合、流（Stream）操作或其他高阶函数时。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式的目的和需求</title>
    <url>/2023/04/28/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #Lambda表达式 #函数式编程</p>
<hr>
<p>Lambda 表达式在 Java 8 中被引入，主要目的是满足以下需求：</p>
<ol>
<li>简化匿名内部类：在 Java 8 之前，开发者通常使用匿名内部类来实现函数式编程。但匿名内部类的语法相对繁琐。Lambda 表达式提供了一种更简洁的方式来表示函数式编程。</li>
</ol>
<p>例如，考虑一个简单的线程创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from anonymous inner class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Hello from Lambda&quot;</span>)).start();</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式，代码更加简洁和易读。</p>
<ol start="2">
<li><p>支持函数式编程：Lambda 表达式是 Java 对函数式编程的支持的一部分，它允许您将函数作为参数传递给其他方法，或者将函数作为返回值。这使得您可以编写更加灵活、模块化的代码，特别是在处理集合、流（Stream）操作或其他高阶函数时。</p>
</li>
<li><p>提高性能：在某些情况下，使用 Lambda 表达式相较于匿名内部类可以带来性能优势，因为 Lambda 表达式可以被编译器优化为静态方法调用，从而减少对象创建和内存开销。</p>
</li>
</ol>
<p>利弊对比：</p>
<ul>
<li>优势：Lambda 表达式的语法简洁，易于阅读和理解。在某些情况下，还可以带来性能优势。</li>
<li>劣势：Lambda 表达式可能导致代码的可读性降低，特别是在较长、复杂的 Lambda 表达式中。此外，对于 Java 8 之前的版本，Lambda 表达式不可用。</li>
</ul>
<p>总之，Lambda 表达式的引入主要是为了简化函数式编程的表示方式，提高代码的可读性和性能。通过使用 Lambda 表达式，您可以编写更加简洁、模块化的代码，特别是在处理集合和流操作时。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP七大原则</title>
    <url>/2023/04/28/OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>时间：2022-04-29<br>标签： #DesignPatterns #OOP </p>
<hr>
<p>开放封闭原则 -&gt; 对扩展开放，对修改关闭</p>
<p>里氏替换原则 -&gt; 继承必须确保超类所拥有的性质在子类中仍然成立</p>
<p>依赖倒置原则 -&gt; 要面向接口编程，不要面对实现编程</p>
<p>单一职责原则 -&gt; 控制类的粒度大小，将对象解耦、提高其内聚性</p>
<p>接口隔离原则 -&gt; 要为各个类江宁里他们需要的专用接口</p>
<p>迪米特法则 -&gt; 只与你的直接朋友交谈，不跟“陌生人说话”</p>
<p>合成复用原则  -&gt; 尽量先使用组合或聚合等关系来实现，其次才考虑继承关系来实现</p>
]]></content>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表操作：添加、删除、修改与访问元素的方法</title>
    <url>/2023/04/23/Python%20%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #Python #列表 #添加 #删除 #修改 #访问</p>
<hr>
<p>Python 的列表（list）是一种可变、有序的数据结构，常用于存储和操作一系列相关数据。在本文中，我们将介绍如何在 Python 中对列表执行添加、删除、修改和访问元素的操作。</p>
<p><strong>1. 添加元素</strong></p>
<p>在 Python 中，可以使用以下方法将元素添加到列表：</p>
<ul>
<li><code>append()</code>: 在列表末尾添加一个元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>]</span><br><span class="line">fruits.append(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>insert()</code>: 在列表指定位置插入一个元素。接受两个参数：插入位置的索引和要插入的元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>]</span><br><span class="line">fruits.insert(<span class="number">1</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>extend()</code>: 将一个列表（或其他可迭代对象）的所有元素添加到另一个列表的末尾。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>]</span><br><span class="line">more_fruits = [<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>]</span><br><span class="line">fruits.extend(more_fruits)</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;grape&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>2. 删除元素</strong></p>
<p>在 Python 中，可以使用以下方法从列表中删除元素：</p>
<ul>
<li><code>remove()</code>: 删除列表中第一个匹配的元素。如果元素不存在，则抛出 ValueError。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line">fruits.remove(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pop()</code>: 删除并返回列表中指定索引处的元素。如果未提供索引，则删除并返回列表中的最后一个元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line">fruit = fruits.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Removed:&quot;</span>, fruit)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;orange&quot;]</span><br><span class="line">Removed: banana</span><br></pre></td></tr></table></figure>

<ul>
<li><code>del</code> 语句：删除列表中的一个或多个元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> fruits[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>3. 修改元素</strong></p>
<p>要修改列表中的元素，可以使用索引直接为其分配一个新值。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line">fruits[<span class="number">1</span>] = <span class="string">&quot;grape&quot;</span></span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;apple&quot;, &quot;grape&quot;, &quot;orange&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>4. 访问元素</strong></p>
<p>要访问列表中的元素，可以使用索引。正索引从 0 开始，负索引从 -1 开始。</p>
<p>示例：</p>
<pre><code class="python">fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]
print(fruits[1])
print(fruits[-1])
</code></pre>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
        <tag>添加</tag>
        <tag>删除</tag>
        <tag>修改</tag>
        <tag>访问</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream. Generate 的作用</title>
    <url>/2023/04/28/Stream.%20Generate%20%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-28<br>标签： #Java #Stream #Streamgenerate</p>
<hr>
<p>Stream. Generate 是 Java 8 引入的 Stream API 中的一个方法，作用是生成一个无限长的流（Stream）对象。这个方法接收一个供给型函数（Supplier），该函数不接收任何参数，每次调用返回一个新的值。Stream. Generate 方法会不断调用该供给型函数以生成元素，直到显式限制流的长度。</p>
<p>具体来说，<code>Stream.generate(Supplier&lt;T&gt; s)</code> 方法的作用是生成一个包含无限个元素的流。每个元素的值由传入的 Supplier 函数提供。由于 Stream 为惰性求值，只有在调用终止操作时才会实际求值。</p>
<p>使用 Stream. Generate 的一个例子：```<br>java<br>import java.util.stream.Stream;</p>
<p>public class StreamGenerateExample {<br>    public static void main(String[] args) {<br>        // 使用Stream.generate生成一个无限流，每个元素都是1<br>        Stream<Integer> stream = Stream.generate(() -&gt; 1);</p>
<pre><code>    // 使用limit方法限制流长度，然后使用forEach打印前10个元素
    stream.limit(10).forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>```</p>
<p>在这个例子中，我们使用Stream.generate生成一个每个元素都是1的无限流。然后我们使用limit方法限制流的长度为10，最后使用forEach打印前10个元素。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
        <tag>Streamgenerate</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder存在的意义是什么</title>
    <url>/2023/04/28/StringBuilder%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>时间：2023-04-24<br>标签： #Java #StringBuilder #StringBuffer #String #MutableStrings #Performance #ThreadSafety #JavaStringBuilder</p>
<hr>
<p>在 Java 编程语言中，处理字符串是一个常见任务。为了实现更高效的字符串操作，Java 提供了多种字符串处理类，如 <code>String</code>, <code>StringBuffer</code>, 和 <code>StringBuilder</code>。本篇博客将重点介绍 <code>StringBuilder</code> 类及其与 <code>StringBuffer</code> 的关系。</p>
<h2 id="为什么需要-StringBuilder？"><a href="#为什么需要-StringBuilder？" class="headerlink" title="为什么需要 StringBuilder？"></a>为什么需要 StringBuilder？</h2><p>尽管 <code>StringBuffer</code> 类为字符串操作提供了可变性和线程安全性，但其线程安全的特性带来了额外的性能开销。在许多场景中，线程安全可能并不是必须的，因此，<code>StringBuilder</code> 类被引入作为一个非线程安全但性能更优的替代方案。<code>StringBuilder</code> 的设计初衷是在单线程环境或不需要线程安全的场景下，提供更快的字符串操作。</p>
<h2 id="StringBuilder-与-StringBuffer-的区别"><a href="#StringBuilder-与-StringBuffer-的区别" class="headerlink" title="StringBuilder 与 StringBuffer 的区别"></a>StringBuilder 与 StringBuffer 的区别</h2><ol>
<li><p>线程安全：<code>StringBuilder</code> 不是线程安全的，而 <code>StringBuffer</code> 是线程安全的。<code>StringBuilder</code> 类的方法没有同步（synchronized），因此在多线程环境下，它的性能通常比 <code>StringBuffer</code> 更好。</p>
</li>
<li><p>性能：<code>StringBuilder</code> 通常比 <code>StringBuffer</code> 具有更高的性能，因为它没有同步开销。</p>
</li>
</ol>
<p>其他方面，如可变性、方法和用法，<code>StringBuilder</code> 与 <code>StringBuffer</code> 非常类似。</p>
<h2 id="如何使用-StringBuilder？"><a href="#如何使用-StringBuilder？" class="headerlink" title="如何使用 StringBuilder？"></a>如何使用 StringBuilder？</h2><p>以下是一些使用 <code>StringBuilder</code> 的示例：</p>
<h3 id="创建-StringBuilder-对象"><a href="#创建-StringBuilder-对象" class="headerlink" title="创建 StringBuilder 对象"></a>创建 StringBuilder 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 创建一个空的 StringBuilder 对象</span></span><br><span class="line">StringBuilder builder2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello, World!&quot;</span>); <span class="comment">// 用指定的字符串创建一个 StringBuilder 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="添加和修改字符串内容"><a href="#添加和修改字符串内容" class="headerlink" title="添加和修改字符串内容"></a>添加和修改字符串内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builder.append(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 追加字符串</span></span><br><span class="line">builder.append(<span class="string">&quot;World!&quot;</span>); <span class="comment">// 追加字符串</span></span><br><span class="line">builder.insert(<span class="number">0</span>, <span class="string">&quot;Welcome! &quot;</span>); <span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">builder.replace(<span class="number">0</span>, <span class="number">8</span>, <span class="string">&quot;Greetings&quot;</span>); <span class="comment">// 替换指定范围的字符串</span></span><br><span class="line">builder.delete(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 删除指定范围的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = builder.length(); <span class="comment">// 获取字符串长度</span></span><br><span class="line"><span class="keyword">char</span> c = builder.charAt(<span class="number">0</span>); <span class="comment">// 获取指定位置的字符</span></span><br><span class="line">String str = builder.toString(); <span class="comment">// 将 StringBuilder 转换为 String</span></span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>StringBuilder</code> 是一个非常实用的类，特别是在不需要线程安全的场景下。它提供了更快的字符串操作，使得在单线程或不需要线程安全的环境中可以大大提高性能。在选择 <code>StringBuffer</code> 和 <code>StringBuilder</code> 时，需要根据实际情况和性能要求来决定使用哪个类。如果线程安全是关键需求，那么使用 <code>StringBuffer</code> 是一个更好的选择；否则，<code>StringBuilder</code> 可能是一个更高效的方案。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
        <tag>StringBuilder</tag>
        <tag>StringBuffer</tag>
        <tag>MutableStrings</tag>
        <tag>Performance</tag>
        <tag>ThreadSafety</tag>
        <tag>JavaStringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>Tkinter 中的布局管理：grid () 与 pack () 的区别与用法</title>
    <url>/2023/04/23/Tkinter%20%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%EF%BC%9Agrid%20()%20%E4%B8%8E%20pack%20()%20%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签: #Tkinter #布局管理 #grid #pack #Python</p>
<hr>
<p>在使用 Tkinter 构建图形用户界面时，布局管理是一个重要的概念。Tkinter 提供了几种布局管理方法，如 grid () 和 pack ()。本文将介绍这两种方法的区别与用法，帮助您在实际项目中做出合适的选择。</p>
<p><strong>1. Grid () 布局</strong></p>
<p>Grid () 是一种基于网格的布局管理方法。它将窗口划分为行和列，并将组件放置在特定的单元格中。Grid () 允许您对行和列进行跨度设置、权重分配等，从而实现灵活的布局设计。</p>
<p><strong>1.1 grid () 用法</strong></p>
<p>要使用 grid ()，需要在组件上调用 grid () 方法，并传递 row、column 参数指定组件所在的单元格。可选参数包括 rowspan、columnspan、sticky 等。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line">label1 = tk.Label(root, text=<span class="string">&quot;Label 1&quot;</span>)</span><br><span class="line">label1.grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">label2 = tk.Label(root, text=<span class="string">&quot;Label 2&quot;</span>)</span><br><span class="line">label2.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p><strong>1.2 grid () 优缺点</strong></p>
<p>优点：</p>
<ul>
<li>易于控制和调整组件位置</li>
<li>更适合复杂的布局设计</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能需要更多的代码来设置参数</li>
</ul>
<p><strong>2. Pack () 布局</strong></p>
<p>Pack () 是一种基于盒子模型的布局管理方法。它将组件放置在容器内，并按照先进先出的顺序堆叠组件。Pack () 提供了一些选项，如 side、anchor、fill、expand 等，以实现不同的布局效果。</p>
<p><strong>2.1 pack () 用法</strong></p>
<p>要使用 pack ()，需要在组件上调用 pack () 方法，并传递可选参数，如 side、anchor、fill、expand 等。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line">label1 = tk.Label(root, text=<span class="string">&quot;Label 1&quot;</span>)</span><br><span class="line">label1.pack(side=tk.LEFT)</span><br><span class="line"></span><br><span class="line">label2 = tk.Label(root, text=<span class="string">&quot;Label 2&quot;</span>)</span><br><span class="line">label2.pack(side=tk.LEFT)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p><strong>2.2 pack () 优缺点</strong></p>
<p>优点：</p>
<ul>
<li>代码简洁</li>
<li>适合简单布局</li>
</ul>
<p>缺点：</p>
<ul>
<li>难以实现复杂布局</li>
</ul>
<p><strong>总结</strong></p>
<p>Grid () 和 pack () 布局管理方法在 Tkinter 中都有其应用场景。对于需要精确控制组件位置和布局的复杂界面，grid () 是一个更好的选择。而对于简单的、线性堆叠的布局，pack () 可以提供更简洁的代码。根据项目需求和个人喜好，可以灵活选择使用</p>
]]></content>
  </entry>
  <entry>
    <title>Tkinter 入门：基本组件和概念介绍</title>
    <url>/2023/04/23/Tkinter%20%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%92%8C%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #Tkinter #Python #GUI #入门 #基本组件</p>
<hr>
<p>Tkinter 是 Python 的标准图形用户界面（GUI）库，用于创建桌面应用程序。它提供了许多内置的组件，如按钮、标签和文本框等，以帮助您创建丰富的用户界面。在本文中，我们将介绍 Tkinter 的基本组件和概念，以便您快速入门。</p>
<p><strong>1. 安装 Tkinter</strong></p>
<p>Tkinter 通常与 Python 一起安装。要检查 Tkinter 是否已安装在您的系统上，您可以在 Python 解释器中尝试导入它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br></pre></td></tr></table></figure>

<p>如果没有出现错误，则表明 Tkinter 已成功安装。</p>
<p><strong>2. 创建基本窗口</strong></p>
<p>要使用 Tkinter 创建一个简单的窗口，您可以按照以下步骤操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p>这将创建一个空白窗口。<code>Tk()</code> 函数创建了一个新的顶级窗口（称为根窗口），而 <code>mainloop()</code> 函数使窗口保持打开状态，并处理用户交互。</p>
<p><strong>3. Tkinter 基本组件</strong></p>
<p>Tkinter 提供了许多组件（也称为小部件）来构建用户界面。以下是一些常用的基本组件：</p>
<ul>
<li><strong>Label:</strong> 用于显示文本或图像。</li>
<li><strong>Button:</strong> 用于触发某个操作或命令。</li>
<li><strong>Entry:</strong> 用于获取单行文本输入。</li>
<li><strong>Text:</strong> 用于获取多行文本输入。</li>
<li><strong>Checkbutton:</strong> 用于创建复选框。</li>
<li><strong>Radiobutton:</strong> 用于创建单选框。</li>
<li><strong>Listbox:</strong> 用于显示列表项。</li>
<li><strong>Scrollbar:</strong> 用于在组件上添加滚动功能。</li>
</ul>
<p><strong>4. 添加组件到窗口</strong></p>
<p>要向窗口添加组件，您需要首先创建组件实例，然后将其添加到窗口。例如，要向窗口添加一个标签和一个按钮，您可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_button_click</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Button clicked!&quot;</span>)</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line">label = tk.Label(root, text=<span class="string">&quot;Hello, Tkinter!&quot;</span>)</span><br><span class="line">label.pack()</span><br><span class="line"></span><br><span class="line">button = tk.Button(root, text=<span class="string">&quot;Click me!&quot;</span>, command=on_button_click)</span><br><span class="line">button.pack()</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p>这将在窗口中添加一个标签和一个按钮。当用户单击按钮时，<code>on_button_click</code> 函数将被调用。</p>
<p><strong>5. 布局管理</strong></p>
<p>Tkinter 提供了三种布局管理器，用于控制组件在窗口中的位置：</p>
<ul>
<li><strong>Pack:</strong> 将组件按照它们在代码中的顺序排列。</li>
<li><strong>Grid:</strong> 将组件放置在网格中的指定行和列。</li>
<li><strong>Place:</strong> 将组件放置在窗</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
        <tag>GUI</tag>
        <tag>入门</tag>
        <tag>基本组件</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeSet 的使用场景</title>
    <url>/2023/04/28/TreeSet%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #TreeSet #使用场景 #有序集合</p>
<hr>
<p>TreeSet 是 Java 集合框架中的一种实现，它基于红黑树（一种自平衡的二叉查找树）实现。TreeSet 具有以下特点，适用于以下场景：</p>
<ol>
<li><p>自然排序或自定义排序：</p>
<ul>
<li>TreeSet 中的元素按照自然顺序进行排序，或者可以按照提供的 Comparator 接口实现进行排序。适用于需要对元素进行排序的场景。</li>
</ul>
</li>
<li><p>不允许重复元素：</p>
<ul>
<li>TreeSet 不允许插入重复元素（根据 equals ()方法或 Comparator 接口判断）。适用于需要去重并保持元素有序的场景。</li>
</ul>
</li>
<li><p>快速查找、插入和删除操作：</p>
<ul>
<li>由于 TreeSet 基于红黑树实现，它的查找、插入和删除操作的时间复杂度为 O (log n)。适用于需要快速执行这些操作的场景。</li>
</ul>
</li>
<li><p>查找范围内的元素：</p>
<ul>
<li>TreeSet 提供了诸如 subSet ()、headSet ()和 tailSet ()等方法，方便地获取指定范围内的元素。适用于需要按范围查找元素的场景。</li>
</ul>
</li>
<li><p>查找最大值和最小值：</p>
<ul>
<li>TreeSet 提供了 first ()和 last ()方法，可以快速获取集合中的最小值和最大值。适用于需要获取极值的场景。</li>
</ul>
</li>
</ol>
<p>综上，TreeSet 适用于以下场景：</p>
<ul>
<li>需要对元素进行排序的场景。</li>
<li>需要去重并保持元素有序的场景。</li>
<li>需要快速执行查找、插入和删除操作的场景。</li>
<li>需要按范围查找元素的场景。</li>
<li>需要获取极值的场景。</li>
</ul>
<p>在选择 TreeSet 时，需要注意其不是线程安全的，因此在多线程环境下使用时需要考虑同步问题。另外，TreeSet 不允许插入 null 值。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>TreeSet</tag>
        <tag>使用场景</tag>
        <tag>有序集合</tag>
      </tags>
  </entry>
  <entry>
    <title>WeakHashMap 简介</title>
    <url>/2023/04/28/WeakHashMap%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #WeakHashMap #数据结构</p>
<hr>
<p>WeakHashMap 是 Java 集合框架中的一种特殊类型的 Map，其键（Key）是弱引用。它与常规 HashMap 的主要区别在于，当 WeakHashMap 中的键不再被其他地方引用时，这些键及其对应的值可以被垃圾回收器自动回收。这种特性使得 WeakHashMap 在处理具有短暂生命周期的键时非常有用。</p>
<p>以下是 WeakHashMap 的一些特点：</p>
<ol>
<li><p>弱引用键：WeakHashMap 的键被封装为弱引用。当这些键不再被其他地方强引用时，它们可以被垃圾回收器回收。这有助于避免因长时间保留不再使用的对象而导致的内存泄漏。</p>
</li>
<li><p>自动清理：当垃圾回收器回收了 WeakHashMap 中的键时，与这些键关联的值也会从 Map 中移除。这样，WeakHashMap 可以在不影响其他应用程序功能的情况下自动清理不再使用的数据。</p>
</li>
<li><p>用途：WeakHashMap 通常用于实现缓存、注册表等，这些场景下键的生命周期可能较短，且不再使用的键应该被垃圾回收器回收。</p>
</li>
</ol>
<p>需要注意的是，WeakHashMap 不适用于那些需要长时间保留键值对的场景，因为垃圾回收器可能会在任何时候回收键。在这种情况下，应使用其他类型的 Map，如 HashMap 或 LinkedHashMap。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;String, String&gt; weakMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        String key = <span class="keyword">new</span> String(<span class="string">&quot;WeakKey&quot;</span>);</span><br><span class="line">        weakMap.put(key, <span class="string">&quot;WeakValue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap before GC: &quot;</span> + weakMap);</span><br><span class="line">        key = <span class="keyword">null</span>; <span class="comment">// Remove the strong reference to the key</span></span><br><span class="line">        System.gc(); <span class="comment">// Request garbage collection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for a short period to let GC complete</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap after GC: &quot;</span> + weakMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WeakHashMap before GC: &#123;WeakKey=WeakValue&#125;</span><br><span class="line">WeakHashMap after GC: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，在请求垃圾回收并移除对键的强引用后，WeakHashMap 中的键值对被自动清除。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>WeakHashMap</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2022/06/10/XML/</url>
    <content><![CDATA[<h1 id="XML的用途"><a href="#XML的用途" class="headerlink" title="XML的用途"></a>XML的用途</h1><p>由于语言的不同，在数据的传输上需要一种统一的格式来减少在不同语言间传递的不便。</p>
<p>例如，天气信息是由国家气象局发布的而非是某个个人网站所能预测的，也因此，为了满足不同需求的网站对于天气信息的需要，国家气象局发布的天禧信息即是xml格式的，这种格式可以使其在不同语言中都可以被理解。</p>
<p>那为什么不直接用txt文件呢？我想主要是对于格式的明确，即，每个信息的含义是什么作出统一的解释，方便不同语言直接对于所需要的信息的tag进行定位索取，而不用读取整个文件然后数第几行是XXX属性再传入赋值给变量。</p>
<h1 id="XML是什么"><a href="#XML是什么" class="headerlink" title="XML是什么"></a>XML是什么</h1><p>XML is External Markup Language</p>
<p>XML是用于传输和储存数据所用</p>
<p>XML必须是自定义的，没有官方标签，一定要有含义，就像是起变量名一样。</p>
<h1 id="XML-规则"><a href="#XML-规则" class="headerlink" title="XML 规则"></a>XML 规则</h1><p>文件中有且仅有一个根标签，其余所有的数据都要包含在这个根标签中。</p>
<p>根标签的命名没有硬性要求，但可以选择root作为根节点标签。</p>
<h1 id="XML-HTML-的区别"><a href="#XML-HTML-的区别" class="headerlink" title="XML HTML 的区别"></a>XML HTML 的区别</h1><ul>
<li>XML的标签只能自定义，但是HTML不能自定义；</li>
<li>HTML语法要求不大严格，XML语法非常严格（必须是成对的标签，否则报错）</li>
<li>XML用来传输保存数据，HTML用来展示数据</li>
</ul>
<h1 id="XML头声明"><a href="#XML头声明" class="headerlink" title="XML头声明"></a>XML头声明</h1><p>不强制 可有可无</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br></pre></td></tr></table></figure>

<p>「version」    版本号</p>
<p>「encoding」    编码</p>
<h1 id="XML特点"><a href="#XML特点" class="headerlink" title="XML特点"></a>XML特点</h1><ul>
<li>标签成对</li>
<li>大小写敏感</li>
<li>特殊字符要使用实体字符，例如，&lt;，要用，&amp;lt;</li>
</ul>
<h1 id="XML注释"><a href="#XML注释" class="headerlink" title="XML注释"></a>XML注释</h1><p>和HTML中一样 <!-- --></p>
<h1 id="XML属性"><a href="#XML属性" class="headerlink" title="XML属性"></a>XML属性</h1><p>属性是用来描述标签的一些额外的信息；</p>
<p>但是由于在XML中，所有的标签都是自定义的，没有必要使用属性来作为展示标签的信息，直接用父子关系来体现甚至就可以了。</p>
<p>同时，在解析xml时，属性的解析会带来额外的解析步骤；</p>
<h1 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h1><p>用于注明其包含的所有数据都不需要被解析</p>
<p>语法如下所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[ all of the contents will not be analized ]]&gt;</span><br></pre></td></tr></table></figure>

<p>故，在特殊字符较少时，可以是用实体字符替换；对于段落较长时，可以用CDATA标注；</p>
<p>同时，CDATA一定要大写</p>
<h1 id="XML-解析原理"><a href="#XML-解析原理" class="headerlink" title="XML 解析原理"></a>XML 解析原理</h1><ol>
<li>读区xml文件到内存；</li>
<li>形成dom树；</li>
<li>由dom树生成对象并返回；</li>
</ol>
<h1 id="XPath-用途"><a href="#XPath-用途" class="headerlink" title="XPath 用途"></a>XPath 用途</h1><p>专门用来查找XML数据内容的一门语言</p>
<h1 id="XPath-用法"><a href="#XPath-用法" class="headerlink" title="XPath 用法"></a>XPath 用法</h1><p>用dom树的路径来作为查找参数，简洁了代码语句；</p>
<p>如上述使用方法所示，其返回的结果不一定只有一个标签的值，有可能有多个同名的兄妹标签</p>
<p>路径参数可以是绝对路径也可以是相对路径，同时，也可以使用*，[xxx]来进行全选或有条件的检索；</p>
<p>@xxx 用以表示标签的属性</p>
<p>![Screenshot 2022-06-10 at 01.50.57](/Users/taylor/Library/Application Support/typora-user-images/Screenshot 2022-06-10 at 01.50.57.png)</p>
]]></content>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>char 与 character 有什么区别 java</title>
    <url>/2023/04/28/char%20%E4%B8%8E%20character%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%20java/</url>
    <content><![CDATA[<p>时间：2023-04-24<br>标签： #java #char #character #封装类</p>
<hr>
<p>在 Java 编程语言中，”char” 和 “character” 有一些不同之处，主要体现在以下方面：</p>
<ol>
<li>数据类型：<br>char：<code>char</code> 是 Java 的一种原始数据类型（primitive data type），用于表示单个 Unicode 字符。它的大小为 16 位（2 字节），可以表示从 0 到 65,535 之间的任何值。例如，定义一个 <code>char</code> 类型变量的语法如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Character：<code>Character</code> 是 Java 的一个封装类（wrapper class），它对 <code>char</code> 数据类型进行了封装，提供了一系列实用方法，例如字符分类、转换大小写等。例如，使用 <code>Character</code> 类的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character letter = <span class="keyword">new</span> Character(<span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>功能和方法：<br>char：<code>char</code> 类型本身没有任何方法，只能存储和表示单个字符。<br>Character：<code>Character</code> 类提供了许多用于操作字符的方法，如 <code>isLetter()</code>, <code>isDigit()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code> 等。</li>
</ol>
<p>总之，<code>char</code> 是 Java 中的原始数据类型，用于存储单个字符，而 <code>Character</code> 是一个封装类，为字符操作提供了更丰富的方法。在实际编程中，根据需求选择使用哪种类型。//</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>char</tag>
        <tag>character</tag>
        <tag>封装类</tag>
      </tags>
  </entry>
  <entry>
    <title>python生成与安装requestment文件</title>
    <url>/2023/04/28/python%E7%94%9F%E6%88%90%E4%B8%8E%E5%AE%89%E8%A3%85requestment%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>时间：2023-04-26<br>标签： #python #requestment</p>
<hr>
<p>生成requirements.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>使用requirements.txt安装依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
        <tag>requestment</tag>
      </tags>
  </entry>
  <entry>
    <title>java. Util. Function.* 介绍</title>
    <url>/2023/04/28/java.%20Util.%20Function.*%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #FunctionalInterfaces #javautilFunction</p>
<hr>
<p>Java. Util. Function 包是 Java 8 引入的一个功能性接口（Functional Interface）包，它包含了一组常用的功能性接口，主要用于支持 Lambda 表达式和方法引用等函数式编程特性。这些接口主要可以分为以下几类：</p>
<ol>
<li><p>Function&lt;T, R&gt;</p>
<ul>
<li>Function 接口表示一个接受一个参数并返回结果的函数。它有一个抽象方法 apply (T t)，用于将此函数应用于给定的参数。</li>
<li>示例：Function&lt;Integer, String&gt; intToString = i -&gt; Integer.ToString (i);</li>
</ul>
</li>
<li><p>Consumer<T></p>
<ul>
<li>Consumer 接口表示一个接受一个输入参数且无返回结果的操作。它有一个抽象方法 accept (T t)，用于执行有关参数的操作。</li>
<li>示例：Consumer<String> printer = s -&gt; System.Out.Println (s);</li>
</ul>
</li>
<li><p>Predicate<T></p>
<ul>
<li>Predicate 接口表示一个接受一个参数并返回一个布尔值结果的谓词。它有一个抽象方法 test (T t)，用于根据给定的参数计算布尔值结果。</li>
<li>示例：Predicate<Integer> isEven = i -&gt; i % 2 == 0;</li>
</ul>
</li>
<li><p>Supplier<T></p>
<ul>
<li>Supplier 接口表示一个无输入参数且返回一个结果的供应商。它有一个抽象方法 get ()，用于返回结果。</li>
<li>示例：Supplier<Double> randomDouble = () -&gt; Math.Random ();</li>
</ul>
</li>
<li><p>BiFunction&lt;T, U, R&gt;</p>
<ul>
<li>BiFunction 接口表示一个接受两个参数并返回一个结果的函数。它有一个抽象方法 apply (T t, U u)，用于将此函数应用于给定的参数。</li>
<li>示例：BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;</li>
</ul>
</li>
<li><p>UnaryOperator<T></p>
<ul>
<li>UnaryOperator 接口表示一个接受一个参数并返回相同类型结果的操作。它继承了 Function&lt;T, T&gt; 接口。</li>
<li>示例：UnaryOperator<Integer> square = x -&gt; x * x;</li>
</ul>
</li>
<li><p>BinaryOperator<T></p>
<ul>
<li>BinaryOperator 接口表示一个接受两个相同类型参数并返回相同类型结果的操作。它继承了 BiFunction&lt;T, T, T&gt; 接口。</li>
<li>示例：BinaryOperator<Integer> multiply = (x, y) -&gt; x * y;</li>
</ul>
</li>
</ol>
<p>这些功能性接口的主要目的是提供一组基本的函数签名，以支持 Java 中的函数式编程。它们可以与 Lambda 表达式、方法引用和 Stream API 一起使用，以实现更简洁、易读的代码。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>FunctionalInterfaces</tag>
        <tag>javautilFunction</tag>
      </tags>
  </entry>
  <entry>
    <title>「dictionary」和「python package」的区别</title>
    <url>/2023/04/28/%E3%80%8Cdictionary%E3%80%8D%E5%92%8C%E3%80%8Cpython%20package%E3%80%8D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>时间：2023-04-26<br>标签： #python #dictionary #package</p>
<hr>
<h1 id="简论"><a href="#简论" class="headerlink" title="简论"></a>简论</h1><p>在 pycharm 中新建 python package 文件 下会有一个空的 __init__.py 文件，而 dictionary 文件没有。</p>
<span id="more"></span> 

<h1 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h1><p>dictionary 在pycharm 中就是一个普通的文件夹，用于划分项目内部各文件间关系。</p>
<h1 id="python-package"><a href="#python-package" class="headerlink" title="python package"></a>python package</h1><p>对于 python package 文件夹而言，其会额外自动创建 __init__.py 文件。简单来说，python package 就是一个目录，其中包含一组模块和个 __init__.py 文件</p>
<h2 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a>__init__.py</h2><p>该文件是 python package的唯一标识， 如果删除 __init__.py 文件，则python package会变成 dictionary。</p>
<h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>python 中包和模块有两种导入包方式：精确导入 和 模糊导入。</p>
<p>例如：在function 文件夹下，func.py 中有 func1()，func2()，func3() 三个方法。</p>
<p><strong>精准导入</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> function.func <span class="keyword">import</span> func1,func2</span><br></pre></td></tr></table></figure>

<p><strong>模糊导入</strong>:</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> function.func <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>



<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>  <a href="https://blog.csdn.net/weixin_44250149/article/details/102909411">https://blog.csdn.net/weixin_44250149/article/details/102909411</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>dictionary</tag>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GitHub Desktop 管理本地项目并同步到 GitHub</title>
    <url>/2023/04/23/%E4%BD%BF%E7%94%A8%20GitHub%20Desktop%20%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%90%8C%E6%AD%A5%E5%88%B0%20GitHub/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #GitHub #GitHubDesktop #版本控制 #同步 #项目管理</p>
<hr>
<p>GitHub Desktop 是一款用于管理 GitHub 项目的图形化客户端。它简化了 Git 操作，使用户能够轻松管理本地项目并将其同步到 GitHub。在本文中，我们将介绍如何使用 GitHub Desktop 管理本地项目并将其同步到 GitHub。</p>
<p><strong>1. 安装 GitHub Desktop</strong></p>
<p>首先，访问 <a href="https://desktop.github.com/">GitHub Desktop 官网</a> 下载并安装适用于您的操作系统的 GitHub Desktop 版本。</p>
<p><strong>2. 配置 GitHub 账户</strong></p>
<p>在安装并启动 GitHub Desktop 后，使用您的 GitHub 账户登录。这样做将允许您访问和管理您在 GitHub 上的所有项目。</p>
<p><strong>3. 将本地项目添加到 GitHub Desktop</strong></p>
<p>要将本地项目添加到 GitHub Desktop，请按照以下步骤操作：</p>
<ol>
<li>打开 GitHub Desktop。</li>
<li>点击左上角的 <code>File</code> 菜单，然后选择 <code>Add local repository</code>。</li>
<li>浏览并选择您的本地项目文件夹。</li>
<li>点击 <code>Add Repository</code> 将项目添加到 GitHub Desktop。</li>
</ol>
<p>现在，您的本地项目已添加到 GitHub Desktop，您可以对其进行版本控制。</p>
<p><strong>4. 创建新的 GitHub 仓库</strong></p>
<p>在将本地项目同步到 GitHub 之前，您需要创建一个新的 GitHub 仓库。请按照以下步骤操作：</p>
<ol>
<li>登录到 <a href="https://github.com/">GitHub 网站</a>。</li>
<li>点击右上角的 <code>+</code> 图标，然后选择 <code>New repository</code>。</li>
<li>输入仓库名称、描述（可选）以及其他相关设置。</li>
<li>点击 <code>Create repository</code>。</li>
</ol>
<p>现在，您已成功创建了一个新的 GitHub 仓库，可以将其与本地项目关联。</p>
<p><strong>5. 将本地项目同步到 GitHub</strong></p>
<p>要将本地项目同步到新创建的 GitHub 仓库，请按照以下步骤操作：</p>
<ol>
<li>在 GitHub Desktop 中，选择刚刚添加的本地项目。</li>
<li>点击右上角的 <code>Publish branch</code> 按钮。</li>
<li>在弹出的窗口中，选择您刚刚创建的 GitHub 仓库。</li>
<li>点击 <code>Publish branch</code>。</li>
</ol>
<p>现在，您的本地项目已成功同步到 GitHub。以后，您可以使用 GitHub Desktop 轻松地提交更改、拉取更新以及执行其他 Git 操作。</p>
]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>GitHubDesktop</tag>
        <tag>版本控制</tag>
        <tag>同步</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>从历史的角度来去解释下，为什么要有Collection 和Collections, Path, Paths, Array, Arrays这些这么相似而不能从名称上一下子分别二者的类名被设计在java中么？</title>
    <url>/2023/04/28/%E4%BB%8E%E5%8E%86%E5%8F%B2%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E5%8E%BB%E8%A7%A3%E9%87%8A%E4%B8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89Collection%20%E5%92%8CCollections,%20Path,%20Paths,%20Array,%20Arrays%E8%BF%99%E4%BA%9B%E8%BF%99%E4%B9%88%E7%9B%B8%E4%BC%BC%E8%80%8C%E4%B8%8D%E8%83%BD%E4%BB%8E%E5%90%8D%E7%A7%B0%E4%B8%8A%E4%B8%80%E4%B8%8B%E5%AD%90%E5%88%86%E5%88%AB%E4%BA%8C%E8%80%85%E7%9A%84%E7%B1%BB%E5%90%8D%E8%A2%AB%E8%AE%BE%E8%AE%A1%E5%9C%A8java%E4%B8%AD%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>时间：2023-04-26<br>标签： #Java #Collection #Collections #Path #Paths #Array #Arrays </p>
<hr>
<ol>
<li><p>Collection 和 Collections</p>
<ul>
<li>Collection 是 Java 集合框架的基础接口，定义了一组通用的集合操作方法。List、Set 和 Queue 都是 Collection 的子接口，它们提供了各自特定的数据存储和操作方法。</li>
<li>Collections 是一个工具类，包含了许多静态方法，用于操作集合对象，如排序、查找、同步等。这个类的设计是为了提供一些通用的、与具体实现无关的集合操作方法。</li>
<li>为什么使用相似的名称：Collection 和 Collections 的设计目的是不同的。Collection 是一个接口，用于定义集合操作的通用规范，而 Collections 是一个工具类，用于提供一些集合操作的通用实现。它们之间的关系是互补的，这也是为什么它们的名称如此相似的原因。</li>
</ul>
</li>
<li><p>Path 和 Paths</p>
<ul>
<li>Path 是 Java NIO. 2 的一个接口，表示文件系统中的路径。它提供了许多用于操作路径的方法，如获取文件名、父路径、子路径等。</li>
<li>Paths 是一个工具类，包含了一些静态方法，用于创建 Path 对象。例如，Paths.Get () 方法可以根据一个字符串或者 URI 创建一个 Path 对象。</li>
<li>为什么使用相似的名称：Path 和 Paths 的设计目的是不同的。Path 是一个接口，用于定义路径操作的通用规范，而 Paths 是一个工具类，用于创建和操作 Path 对象。它们之间的关系是互补的，这也是为什么它们的名称如此相似的原因。</li>
</ul>
</li>
<li><p>Array 和 Arrays</p>
<ul>
<li>Array 是 Java 反射 API 的一个类，用于动态创建和访问数组对象。它提供了一些方法，如创建数组、获取数组长度、访问数组元素等。</li>
<li>Arrays 是一个工具类，包含了许多静态方法，用于操作数组，如排序、查找、比较等。这个类的设计是为了提供一些通用的、与具体实现无关的数组操作方法。</li>
<li>为什么使用相似的名称：Array 和 Arrays 的设计目的是不同的。Array 是一个类，用于动态地创建和访问数组，而 Arrays 是一个工具类，用于提供一些数组操作的通用实现。它们之间的关系是互补的，这也是为什么它们的名称如此相似的原因。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Path</tag>
        <tag>Paths</tag>
        <tag>Collection</tag>
        <tag>Collections</tag>
        <tag>Array</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Tkinter 构建药物剂量计算器：设计用户界面</title>
    <url>/2023/04/23/%E4%BD%BF%E7%94%A8%20Tkinter%20%E6%9E%84%E5%BB%BA%E8%8D%AF%E7%89%A9%E5%89%82%E9%87%8F%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #Tkinter #Python #GUI #药物剂量计算器 #用户界面</p>
<hr>
<p>在本教程中，我们将介绍如何使用 Python 的 Tkinter 库构建一个药物剂量计算器。此计算器将帮助用户输入患者信息，如年龄、体重等，并根据这些信息计算药物剂量。我们将重点关注如何设计和实现用户界面。</p>
<p><strong>1. 准备工作</strong></p>
<p>首先，导入所需的库并创建一个根窗口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br></pre></td></tr></table></figure>

<p><strong>2. 设计界面</strong></p>
<p>我们将创建以下组件：</p>
<ul>
<li>年龄输入框（Spinbox）</li>
<li>怀孕状态单选按钮（Radiobutton）</li>
<li>过敏状态单选按钮（Radiobutton）</li>
<li>体重输入框（Spinbox）</li>
<li>提交按钮（Button）</li>
<li>显示结果的标签（Label）</li>
</ul>
<p><strong>3. 创建组件</strong></p>
<p>创建组件实例，并设置相关属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age_label = tk.Label(root, text=<span class="string">&quot;Age:&quot;</span>)</span><br><span class="line">age_spinbox = ttk.Spinbox(root, from_=<span class="number">0</span>, to=<span class="number">120</span>, increment=<span class="number">1</span>, width=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">pregnant_label = tk.Label(root, text=<span class="string">&quot;Pregnant:&quot;</span>)</span><br><span class="line">pregnant_var = tk.StringVar()</span><br><span class="line">pregnant_yes = tk.Radiobutton(root, text=<span class="string">&quot;Yes&quot;</span>, variable=pregnant_var, value=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">pregnant_no = tk.Radiobutton(root, text=<span class="string">&quot;No&quot;</span>, variable=pregnant_var, value=<span class="string">&quot;N&quot;</span>)</span><br><span class="line"></span><br><span class="line">allergy_label = tk.Label(root, text=<span class="string">&quot;Allergy:&quot;</span>)</span><br><span class="line">allergy_var = tk.StringVar()</span><br><span class="line">allergy_yes = tk.Radiobutton(root, text=<span class="string">&quot;Yes&quot;</span>, variable=allergy_var, value=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">allergy_no = tk.Radiobutton(root, text=<span class="string">&quot;No&quot;</span>, variable=allergy_var, value=<span class="string">&quot;N&quot;</span>)</span><br><span class="line"></span><br><span class="line">weight_label = tk.Label(root, text=<span class="string">&quot;Weight (kg):&quot;</span>)</span><br><span class="line">weight_spinbox = ttk.Spinbox(root, from_=<span class="number">0</span>, to=<span class="number">300</span>, increment=<span class="number">0.5</span>, width=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;Calculate&quot;</span>, command=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">result_label = tk.Label(root, text=<span class="string">&quot;Result:&quot;</span>)</span><br><span class="line">result_var = tk.StringVar()</span><br><span class="line">result_value = tk.Label(root, textvariable=result_var)</span><br></pre></td></tr></table></figure>

<p><strong>4. 布局组件</strong></p>
<p>使用 <code>grid()</code> 布局管理器将组件放置在窗口中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age_label.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, padx=<span class="number">20</span>, pady=<span class="number">10</span>)</span><br><span class="line">age_spinbox.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pregnant_label.grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">pregnant_yes.grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line">pregnant_no.grid(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">allergy_label.grid(row=<span class="number">2</span>, column=<span class="number">0</span>)</span><br><span class="line">allergy_yes.grid(row=<span class="number">2</span>, column=<span class="number">1</span>)</span><br><span class="line">allergy_no.grid(row=<span class="number">2</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">weight_label.grid(row=<span class="number">3</span>, column=<span class="number">0</span>)</span><br><span class="line">weight_spinbox.grid(row=<span class="number">3</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">submit_button.grid(row=<span class="number">4</span>, column=<span class="number">0</span>, pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">result_label.grid(row=<span class="number">5</span>, column=<span class="number">0</span>)</span><br><span class="line">result_value.grid(row=<span class="number">5</span>, column=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>5. 定义计算药物剂量的函数</strong></p>
<p>创建一个函数 <code>calculate_dosage()</code>，用于计算药物剂量。这个函数将获取用户输入的年龄、怀孕状态、过敏状态和体重，并根据这些信息计算药物剂量。为了简化，我们假设药物剂量仅与体重相关。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_dosage</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        age = <span class="built_in">int</span>(age_spinbox.get())</span><br><span class="line">        pregnant = pregnant_var.get() == <span class="string">&quot;Y&quot;</span></span><br><span class="line">        allergy = allergy_var.get() == <span class="string">&quot;Y&quot;</span></span><br><span class="line">        weight = <span class="built_in">float</span>(weight_spinbox.get())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 简化的剂量计算，实际应用可能需要更复杂的计算</span></span><br><span class="line">        dosage = weight * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        result_var.<span class="built_in">set</span>(<span class="string">f&quot;Dosage: <span class="subst">&#123;dosage&#125;</span> mg&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        result_var.<span class="built_in">set</span>(<span class="string">&quot;Invalid input&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>6. 绑定提交按钮</strong></p>
<p>将 <code>calculate_dosage</code> 函数绑定到提交按钮的 <code>command</code> 属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submit_button.config(command=calculate_dosage)</span><br></pre></td></tr></table></figure>

<p><strong>7. 运行程序</strong></p>
<p>最后，使用 <code>mainloop()</code> 函数启动程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>

<p>现在，当用户输入患者信息并单击“计算”按钮时，程序将计算药物剂量并在结果标签中显示。</p>
<p>本教程向您展示了如何使用 Tkinter 构建一个简单的药物剂量计算器。虽然本示例非常简化，但它提供了一个很好的起点，您可以根据需要添加更多功能，如复杂的剂量计算、其他药物类型等。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
        <tag>GUI</tag>
        <tag>药物剂量计算器</tag>
        <tag>用户界面</tag>
      </tags>
  </entry>
  <entry>
    <title>值复制与引用复制的区别</title>
    <url>/2023/04/28/%E5%80%BC%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #值复制 #引用复制 #示例</p>
<hr>
<p>值复制和引用复制是在操作变量和对象时的两种不同方式。以下是它们之间的根本区别：</p>
<p>值复制（Value Copy）：<br>值复制是指将一个变量的值复制到另一个变量。在这种情况下，两个变量拥有相同的值，但它们在内存中位于不同的位置。它们互不影响，对其中一个变量的操作不会影响另一个变量。值复制通常用于基本数据类型（如 int，float，double 等）。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">// 值复制</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">System.out.println(a); <span class="comment">// 输出：10</span></span><br><span class="line">System.out.println(b); <span class="comment">// 输出：20</span></span><br></pre></td></tr></table></figure>

<p>引用复制（Reference Copy）：<br>引用复制是指将一个对象的引用复制到另一个对象。在这种情况下，两个变量指向内存中的同一个对象，因此它们共享相同的数据。对其中一个变量的操作会影响另一个变量，因为它们实际上引用的是同一个对象。引用复制通常用于对象类型（如自定义类，集合等）。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list2 = list1; <span class="comment">// 引用复制</span></span><br><span class="line">list2.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list1); <span class="comment">// 输出：[1, 2, 3]</span></span><br><span class="line">System.out.println(list2); <span class="comment">// 输出：[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>list2</code> 是 <code>list1</code> 的引用复制。它们都指向内存中的同一个对象，因此对 <code>list2</code> 的操作（添加元素 3）也影响了 <code>list1</code>。</p>
<p>总之，值复制与引用复制的根本区别在于它们操作变量和对象的方式。值复制创建了两个独立的变量，它们具有相同的值，但不会互相影响。而引用复制让两个变量指向同一个对象，它们共享相同的数据，对其中一个的操作会影响另一个。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>示例</tag>
        <tag>值复制</tag>
        <tag>引用复制</tag>
      </tags>
  </entry>
  <entry>
    <title>单独的工厂类 (Separate Factory Class)</title>
    <url>/2023/04/28/%E5%8D%95%E7%8B%AC%E7%9A%84%E5%B7%A5%E5%8E%82%E7%B1%BB%20(Separate%20Factory%20Class)/</url>
    <content><![CDATA[<p>时间：2023-04-28<br>标签： #Java #设计模式 #工厂模式 #工厂类</p>
<hr>
<p>单独的工厂类（Separate Factory Class）是指在软件设计中，使用一个独立的类专门负责创建其他类的对象。这种方法是工厂模式（Factory Pattern）的一种实现，它将对象的创建过程与使用过程分离，使得客户端在使用对象时不需要关心对象的创建细节。</p>
<p>使用单独的工厂类有以下优点：</p>
<ol>
<li>代码解耦：将对象创建逻辑与对象使用逻辑分离，提高了代码的可维护性和可扩展性。</li>
<li>降低代码重复：集中管理对象的创建，避免在多个地方重复创建相同类型的对象。</li>
<li>控制对象创建：工厂类可以对创建过程进行控制，如限制对象的数量、单例模式等。</li>
</ol>
<p>一个简单的工厂类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独的工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;dog&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;cat&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal dog = AnimalFactory.createAnimal(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.speak();</span><br><span class="line"></span><br><span class="line">        Animal cat = AnimalFactory.createAnimal(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个 Animal 接口以及两个实现类 Dog 和 Cat。然后创建了一个单独的工厂类 AnimalFactory，负责根据传入的类型字符串创建对应的 Animal 对象。客户端代码通过调用工厂类的静态方法 <code>createAnimal</code> 创建对象，无需关心对象的具体创建过程。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
        <tag>工厂类</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Java 中, Collection 类和 ArrayList 之间的关系</title>
    <url>/2023/04/28/%E5%9C%A8%20Java%20%E4%B8%AD,%20Collection%20%E7%B1%BB%E5%92%8C%20ArrayList%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>时间：2023-04-25<br>标签： #Java #Collection #ArrayList</p>
<hr>
<ol>
<li><p>集合框架层次结构</p>
<ul>
<li>Java 集合框架 (Collections Framework) 是 Java 标准库的一部分，提供了一套用于存储和操作数据集合的接口和实现类。</li>
<li>Collection 接口是 Java 集合框架的基础接口，所有的集合类都实现了这个接口。</li>
<li>List、Set 和 Queue 都是 Collection 的子接口，它们提供了各自特定的数据存储和操作方法。</li>
<li>ArrayList 是 List 接口的一个实现类，是一个动态数组，可以自动调整大小。</li>
</ul>
</li>
<li><p>ArrayList 的特点</p>
<ul>
<li>ArrayList 是一个可变大小的数组，提供了灵活的插入、删除和查找操作。</li>
<li>ArrayList 是基于索引的数据结构，访问元素的时间复杂度是 O (1)。</li>
<li>ArrayList 的插入和删除操作可能需要移动数组中的元素，因此它们的时间复杂度可能是 O (n)。</li>
<li>ArrayList 是非线程安全的，如果需要在多线程环境下使用，可以考虑使用 Collections.SynchronizedList () 方法来包装它，或者使用线程安全的实现类，如 java. Util. Concurrent. CopyOnWriteArrayList。</li>
</ul>
</li>
<li><p>Collection 和 ArrayList 的关系</p>
<ul>
<li>ArrayList 是实现了 Collection 接口的一个具体类，它继承了 Collection 提供的通用方法，如 add ()、remove ()、contains () 等。</li>
<li>通过实现 List 接口，ArrayList 还提供了额外的方法，如 get ()、set ()、indexOf () 等，这些方法使得 ArrayList 更适合于顺序访问和随机访问的场景。</li>
<li>由于 ArrayList 是一个 Collection 实现类，您可以将其作为一个普通的 Collection 对象来使用，这样可以提高代码的通用性和可扩展性。</li>
</ul>
</li>
</ol>
<p>总结：Collection 是 Java 集合框架中的一个基础接口，而 ArrayList 是实现了 Collection 和 List 接口的一个具体类。ArrayList 继承了 Collection 的方法，并添加了额外的 List 方法，使其成为一个功能丰富且灵活的数据结构。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>变量捕获（Variable Capture）</title>
    <url>/2023/04/28/%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%EF%BC%88Variable%20Capture%EF%BC%89/</url>
    <content><![CDATA[<p>时间：2023-04-26<br>标签： #Java #Lambda #AnonymousClass #VariableCapture</p>
<hr>
<p>变量捕获是指在闭包（如 Lambda 表达式或匿名内部类）中访问和使用其外部作用域的变量的过程。在 Java 中，变量捕获主要出现在以下两种场景：</p>
<ol>
<li><p>匿名内部类中的变量捕获</p>
<ul>
<li>在匿名内部类中，可以访问其外部作用域的 final 变量。在 Java 8 之前，这些变量必须显式地声明为 final。</li>
<li>从 Java 8 开始，引入了 effectively final 的概念，即使变量没有显式地声明为 final，只要它们在初始化之后没有被修改，就可以在匿名内部类中使用。</li>
</ul>
</li>
<li><p>Lambda 表达式中的变量捕获</p>
<ul>
<li>Lambda 表达式也可以捕获其外部作用域的变量，但这些变量必须是 final 或 effectively final。</li>
<li>要求捕获的变量是 final 或 effectively final 的原因是为了避免多线程环境下的数据竞争和同步问题。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableCaptureExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类中的变量捕获</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Anonymous Class localVar: &quot;</span> + localVar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda 表达式中的变量捕获</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Lambda localVar: &quot;</span> + localVar)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：变量捕获是指在闭包（如 Lambda 表达式或匿名内部类）中访问和使用其外部作用域的变量的过程。在 Java 中，这些捕获的变量必须是 final 或 effectively final，以避免多线程环境下的数据竞争和同步问题。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>AnonymousClass</tag>
        <tag>VariableCapture</tag>
      </tags>
  </entry>
  <entry>
    <title>多次调用 stream ()方法创建新的流</title>
    <url>/2023/04/28/%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%20stream%20()%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%B5%81/</url>
    <content><![CDATA[<p>时间：2023-04-28<br>标签： #Java #Stream #字符串处理</p>
<hr>
<p>在提供的代码中，<code>FileToWordsRegexp</code> 类的构造器将文件内容读取到一个字符串变量 <code>all</code> 中（跳过第一行注释，并将其转换为单行字符串）。接下来，类中的 <code>stream()</code> 方法使用这个 <code>all</code> 字符串来创建一个新的流。</p>
<p>在 <code>main</code> 方法中，我们可以看到 <code>stream()</code> 方法被多次调用以在已存储的字符串 <code>all</code> 中创建新的流。请参考以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fw.stream()</span><br><span class="line">  .limit(<span class="number">7</span>)</span><br><span class="line">  .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">  .forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">fw.stream()</span><br><span class="line">  .skip(<span class="number">7</span>)</span><br><span class="line">  .limit(<span class="number">2</span>)</span><br><span class="line">  .map(w -&gt; w + <span class="string">&quot; &quot;</span>)</span><br><span class="line">  .forEach(System.out::print);</span><br></pre></td></tr></table></figure>

<p>在这两个代码片段中，我们分别调用了两次 <code>fw.stream()</code> 方法。每次调用都会创建一个新的基于 <code>all</code> 字符串的流。第一次调用 <code>fw.stream()</code> 时，我们限制了流的前 7 个元素并打印它们。第二次调用 <code>fw.stream()</code> 时，我们跳过了前 7 个元素，然后限制接下来的 2 个元素并打印它们。</p>
<p>这个例子展示了如何多次调用 <code>stream()</code> 方法在已存储的字符串中创建一个新的流。因为 <code>all</code> 字符串是在构造器中读取并存储的，所以我们可以在同一个 <code>FileToWordsRegexp</code> 实例上多次调用 <code>stream()</code> 方法，每次都会返回一个新的基于 <code>all</code> 字符串的流。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Python 中实现字符串的分割、判断与去重</title>
    <url>/2023/04/23/%E5%A6%82%E4%BD%95%E5%9C%A8%20Python%20%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%8E%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #Python #字符串 #分割 #判断 #去重</p>
<hr>
<p>在 Python 编程中，字符串处理是常见的任务之一。本文将介绍如何在 Python 中实现字符串的分割、判断与去重，以帮助您在实际项目中更高效地处理字符串数据。</p>
<p><strong>1. 字符串分割</strong></p>
<p>Python 提供了 split () 方法，用于将字符串分割成多个子字符串。Split () 方法接受一个参数，即分隔符，用于指定字符串应如何分割。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;apple,banana,orange&quot;</span></span><br><span class="line">split_text = text.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(split_text)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>2. 字符串判断</strong></p>
<p>要判断字符串是否满足特定条件，可以使用 Python 提供的一些内置方法，如 isdigit ()、isalpha () 等。这些方法返回一个布尔值，表示字符串是否满足相应条件。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;1234&quot;</span></span><br><span class="line">result = text.isdigit()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>3. 字符串去重</strong></p>
<p>为了去除字符串中的重复字符，可以使用 set 数据结构。首先，将字符串转换为 set，然后再将 set 转换回字符串。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;banana&quot;</span></span><br><span class="line">unique_text = <span class="string">&quot;&quot;</span>.join(<span class="built_in">set</span>(text))</span><br><span class="line"><span class="built_in">print</span>(unique_text)</span><br></pre></td></tr></table></figure>

<p>输出（结果顺序可能会有所不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anb</span><br></pre></td></tr></table></figure>

<p><strong>4. 综合示例</strong></p>
<p>下面的示例展示了如何将字符串分割、判断和去重操作结合起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;1,2,2,3,4,4,4&quot;</span></span><br><span class="line">parts = text.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断所有子字符串都是数字</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">all</span>(part.isdigit() <span class="keyword">for</span> part <span class="keyword">in</span> parts):</span><br><span class="line">    <span class="comment"># 去重</span></span><br><span class="line">    unique_parts = <span class="built_in">list</span>(<span class="built_in">set</span>(parts))</span><br><span class="line">    <span class="built_in">print</span>(unique_parts)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Some parts are not digits.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>Python 提供了丰富的字符串处理方法，可帮助您轻松实现字符串的分割、判断和去重操作。根据实际需求，可以灵活组合这些方法以完成任务。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>字符串</tag>
        <tag>分割</tag>
        <tag>判断</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Java 中使用 Deque 实现栈而不是 Stack 类</title>
    <url>/2023/04/28/%E5%9C%A8%20Java%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Deque%20%E5%AE%9E%E7%8E%B0%E6%A0%88%E8%80%8C%E4%B8%8D%E6%98%AF%20Stack%20%E7%B1%BB/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #Deque #Stack #历史原因</p>
<hr>
<p>是的，因为历史原因，在现代 Java 编程中，我们建议使用 Deque（双端队列）来实现栈而不是使用 Stack 类。以下是原因解释：</p>
<ol>
<li><p>更现代的 API：</p>
<ul>
<li>Stack 类是 Java 1.0 中引入的，而 Deque 接口是 Java 1.6 中引入的。Deque 接口提供了更现代的 API 设计，使得代码更具可读性和易用性。</li>
</ul>
</li>
<li><p>更灵活的数据结构：</p>
<ul>
<li>Deque 允许在队列的两端进行插入和删除操作，因此可以用作栈和队列。使用 Deque 实现栈可以让你的代码更具灵活性，便于扩展和修改。</li>
</ul>
</li>
<li><p>更好的性能：</p>
<ul>
<li>Stack 类是基于 Vector 实现的，而 Vector 是同步的（线程安全）。虽然这在某些场景下是有用的，但在许多情况下，这会导致不必要的性能开销。而 Deque 的实现（如 ArrayDeque）通常提供了更好的性能，因为它们是非同步的（线程不安全）。当然，在多线程环境下使用 Deque 时需要注意同步问题。</li>
</ul>
</li>
<li><p>符合 Java 集合框架：</p>
<ul>
<li>Stack 类不属于 Java 集合框架，而 Deque 接口是集合框架的一部分。使用 Deque 实现栈可以让你的代码更符合 Java 集合框架的编程习惯。</li>
</ul>
</li>
</ol>
<p>综上，鉴于 Deque 的现代 API 设计、灵活性、性能优势以及与 Java 集合框架的兼容性，我们建议在现代 Java 编程中使用 Deque 来实现栈，而不是使用 Stack 类。这样可以让代码更具可读性、易用性和灵活性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Deque</tag>
        <tag>Stack</tag>
        <tag>历史原因</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2023/04/28/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>时间：2022-04-29<br>标签： #DesignPatterns #工厂模式</p>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul>
<li><p>  简单工厂</p>
</li>
<li><p>工厂方法</p>
<p>  疑问1: 工厂方法为什么相对来讲有是个好模式呢？让所有的汽车都实现Car接口，又设计CarFactory接口来让所有的汽车工厂实现，这和直接调用所有汽车类的方法有什么区别么？</p>
</li>
<li><p>  抽象工厂</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>方法引用的目的和需求</title>
    <url>/2023/04/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #方法引用 #Lambda表达式 #函数式编程</p>
<hr>
<p>方法引用（Method Reference）在 Java 8 中被引入，主要是为了满足以下需求：</p>
<ol>
<li>简化 Lambda 表达式：方法引用可以简化一些简单的 Lambda 表达式，使代码更加简洁、易读。当 Lambda 表达式的实现仅仅是调用一个已有的方法时，使用方法引用更加直观。例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">list.stream().map(str -&gt; str.toUpperCase()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用</span></span><br><span class="line">list.stream().map(String::toUpperCase).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>复用现有代码：方法引用允许您直接引用现有的静态方法、实例方法或构造函数，从而避免重复编写相同的逻辑。这有助于提高代码的复用性和可维护性。</p>
</li>
<li><p>支持函数式编程：方法引用是 Java 对函数式编程的支持的一部分，它允许您将方法作为参数传递给其他方法，或者将方法作为返回值。这使得您可以编写更加灵活、模块化的代码，特别是在处理集合、流（Stream）操作或其他高阶函数时。</p>
</li>
</ol>
<p>总之，方法引用的引入主要是为了提高代码的简洁性、可读性和复用性，同时支持函数式编程的编程范式。通过使用方法引用，您可以更加简洁地表示现有方法的调用，从而使代码更加整洁、易于理解。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>函数式编程</tag>
        <tag>Lambda表达式</tag>
        <tag>方法引用</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口</title>
    <url>/2022/04/26/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>时间： 2022-04-26<br>标签： #抽象类 #接口 </p>
<hr>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类中不是只能有抽象方法，也可以有具体方法。</p>
<p>抽象方法只有定义没有实现。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是一个与类相似的结构，只包含常量和抽象方法。</p>
<p>接口的很多方面都和抽象类很相似，但是它的目的是指明相关或者不相关类的多个对象的共同行为。（无视类与类之间的关系，专注于的是方法本身）</p>
<p>类和接口之间的关系称为「接口继承」（interface inheritance）-&gt; 因为接口继承和类继承本质上是相同的。</p>
<p>开发调用的是接口，接口规划功能，接口的具体实现在接口继承的方法中。</p>
<p>接口可以继承其他接口</p>
<p>问题：接口是如何实现对于类进行隐藏，让程序员只专注于暴露的接口的呢？程序员看不到类本身么？好像也是可以看到的呀？在代码中拿不到么？好像也拿得到呀？所以接口更像是的君子协议而已？当我们看到如下代码的时候，类不也自然是暴露出来了么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Filter filter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        filter = <span class="keyword">new</span> AgeFilter();</span><br><span class="line">        filter.doFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AgeFilter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>方法引用（Method Reference）简介</title>
    <url>/2023/04/28/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%88Method%20Reference%EF%BC%89%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #方法引用 #Lambda表达式</p>
<hr>
<p>方法引用（Method Reference）是 Java 8 引入的一种简化 lambda 表达式的语法。它允许您直接引用现有方法（静态方法、实例方法、构造函数）而无需显式地编写 lambda 表达式。方法引用通常用在函数式接口的实现中，例如在流（Stream）操作或其他高阶函数中。</p>
<p>方法引用有四种类型：</p>
<ol>
<li>静态方法引用：当引用的方法是一个静态方法时，使用类名:: 方法名的形式表示。例如，<code>Integer::parseInt</code> 是 <code>Integer</code> 类的 <code>parseInt</code> 静态方法的引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; parseInt = Integer::parseInt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实例方法引用：当引用的方法是一个实例方法时，使用对象实例:: 方法名的形式表示。例如，<code>str::toUpperCase</code> 是 <code>str</code> 实例的 <code>toUpperCase</code> 方法的引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Supplier&lt;String&gt; toUpperCase = str::toUpperCase;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类的实例方法引用：当引用的方法是一个实例方法，但需要用类名引用时，使用类名:: 方法名的形式表示。这种情况下，第一个参数会成为方法的调用者。例如，<code>String::compareToIgnoreCase</code> 是 <code>String</code> 类的 <code>compareToIgnoreCase</code> 实例方法的引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; ignoreCaseComparator = String::compareToIgnoreCase;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>构造函数引用：当引用的方法是一个类的构造函数时，使用类名:: new 的形式表示。例如，<code>ArrayList::new</code> 是 <code>ArrayList</code> 类的构造函数引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;ArrayList&lt;String&gt;&gt; arrayListSupplier = ArrayList::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p>方法引用提供了一种更简洁、易读的方式来表示 lambda 表达式，尤其是在函数签名与现有方法签名完全匹配的情况下。</p>
<p>在没有方法引用的情况下，我们可以使用 Lambda 表达式来实现上述示例。这里是原始示例（使用方法引用）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().map(String::toUpperCase).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>在不使用方法引用的情况下，我们可以将其改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().map(str -&gt; str.toUpperCase()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们使用了 Lambda 表达式 <code>str -&gt; str.toUpperCase()</code> 来替换原始的方法引用 <code>String::toUpperCase</code>。这个 Lambda 表达式接收一个字符串参数 <code>str</code>，并调用其 <code>toUpperCase()</code> 方法将其转换为大写。虽然这种写法相对于方法引用略显冗长，但在不支持方法引用的情况下，它仍然是一种简洁、易读的替代方案。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Lambda表达式</tag>
        <tag>方法引用</tag>
      </tags>
  </entry>
  <entry>
    <title>柯里化（Currying）存在的意义是什么？</title>
    <url>/2023/04/28/%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88Currying%EF%BC%89%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Currying #FunctionalProgramming </p>
<hr>
<p>柯里化（Currying）是函数式编程中的一个概念，它是将一个接受多个参数的函数转换成一系列只接受单个参数的函数的过程。柯里化的存在具有以下几个意义：</p>
<ol>
<li><p>参数复用</p>
<ul>
<li>通过柯里化，我们可以创建部分应用的函数（Partially Applied Function），这些函数可以复用之前传递的参数。这使得我们可以避免重复传递相同的参数，简化函数调用。</li>
</ul>
</li>
<li><p>更简洁的代码</p>
<ul>
<li>柯里化可以使我们的代码更加简洁，因为我们可以通过链式调用来传递参数。这样可以减少代码的冗余，提高代码的可读性。</li>
</ul>
</li>
<li><p>延迟计算</p>
<ul>
<li>柯里化允许我们在将参数传递给函数时创建闭包，从而将计算延迟到实际需要结果的时候。这可以帮助我们优化性能，避免不必要的计算。</li>
</ul>
</li>
<li><p>更好的组合性</p>
<ul>
<li>柯里化后的函数具有更好的组合性，因为它们的输入和输出都是单个参数。这使得我们可以轻松地将它们组合在一起，创建出更复杂的函数。</li>
</ul>
</li>
<li><p>易于理解和调试</p>
<ul>
<li>柯里化后的函数更加模块化，这使得它们更容易理解和调试。因为每个函数都只关心一个参数，所以我们可以更容易地分析它们的行为，以及它们是如何相互作用的。</li>
</ul>
</li>
</ol>
<p>总结：柯里化存在的意义主要体现在参数复用、代码简洁、延迟计算、更好的组合性以及易于理解和调试等方面。它可以帮助我们编写更简洁、模块化、高效的代码。</p>
]]></content>
      <tags>
        <tag>Currying</tag>
        <tag>FunctionalProgramming</tag>
      </tags>
  </entry>
  <entry>
    <title>栈、堆、执行栈及栈帧的辨析</title>
    <url>/2022/05/01/%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%89%A7%E8%A1%8C%E6%A0%88%E5%8F%8A%E6%A0%88%E5%B8%A7%E7%9A%84%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<h1 id="堆-heap-和栈-stack"><a href="#堆-heap-和栈-stack" class="headerlink" title="堆(heap)和栈(stack)"></a>堆(heap)和栈(stack)</h1><p>js数据类型分为「基本类型」和「引用类型」，「基本类型」在内存中占据固定大小的空间，引用类型大小不定，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">23</span> <span class="comment">// 变量声明后可知多少字节</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tz里面写了什么只有调用的时候才会知道，函数tz声明后会在内存开辟一段空间</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  结论：栈(stack)自动分配内存空间，存放基本类型和引用类型值的地址；堆动态分配的内存，存放引用类型,可以使用栈中的键名来取得。</li>
</ul>
<p>js引擎不能直接操作堆内存中的数据，这就造成了对同一个变量赋不同类型的值，会出现完全不同的效果：为一个变量赋基本值时，实际上是创建一个新值，然后把该值赋给新变量，可以说这是一种真正意义上的赋值。 为一个变量赋引用值时，实际上是为新变量添加一个指针，指向堆内存中的一个对象，属于一种赋址操作。——摘自</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">23</span>;</span><br><span class="line">let obj = &#123;a:&#123;b:<span class="number">1</span>&#125;&#125;</span><br><span class="line">let obj2 = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量a直接存储在栈中，变量obj和obj2指向堆中的同一个对象，属于该对象的指针。</span></span><br></pre></td></tr></table></figure>

<h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>每个函数被调用时会创建自己的执行上下文，主程序代码函数多了就会有自己独特的管理方式。<br>js引擎创建了执行栈来管理执行上下文。可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fn2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   fn3()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br></pre></td></tr></table></figure>

<p>fn3最后进入栈顶，但最先执行完，其执行上下文（这里理解为函数的当前执行环境）最先出栈并等待垃圾回收，遵循了后进先出的原则，fn2、fn1以此类推。</p>
<ul>
<li>  总结如下：</li>
</ul>
<p>JavaScript执行在单线程上，所有的代码都是排队执行。<br>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。<br>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。<br>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。<br>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</p>
<h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>栈帧是指为一个函数调用单独分配的那部分栈空间。<br>运行的程序从当前函数调用另外一个函数时，就会为下一个函数建立一个新的栈帧，并且进入这个栈帧，这个栈帧称为当前帧。而原来的函数也有一个对应的栈帧，被称为调用帧。每一个栈帧里面都会存入当前函数的局部变量</p>
<p>当函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数。并将程序运行权利（帧指针）交给此时栈顶的栈帧。这种后进后出的结构也就是函数的调用栈。</p>
<blockquote>
<p>  引用：<a href="https://blog.csdn.net/weixin_40594127/article/details/106790866">https://blog.csdn.net/weixin_40594127/article/details/106790866</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>heap</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型类型表示为 T 的原因</title>
    <url>/2023/04/28/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA%E4%B8%BA%20T%20%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #Java #泛型 #类型表示 #T</p>
<hr>
<p>在 Java 中，使用 T 作为泛型类型的表示是一种编程惯例。这里的 T 代表“Type”（类型）。Java 泛型编程的惯例主要有以下几种：</p>
<ol>
<li>T：表示泛型的类型，意为 Type。通常用于单一类型参数的泛型类或方法。</li>
<li>E：表示集合的元素类型，意为 Element。通常用于与集合元素相关的泛型类或方法。</li>
<li>K、V：分别表示映射中的键（Key）和值（Value）类型。通常用于与映射（Map）相关的泛型类或方法。</li>
<li>N：表示数字类型，意为 Number。通常用于与数字相关的泛型类或方法。</li>
<li>S、U、V 等：表示其他类型参数。当需要多个类型参数时，可以使用这些字母。这些字母通常按照字母表顺序使用。</li>
</ol>
<p>以上编程惯例有助于提高代码的可读性，使得其他开发者更容易理解泛型类或方法的功能和用途。在示例中，使用 T 作为泛型类型表示，表明 Stack 类支持泛化的数据类型。这样，Stack 类可以在不同的类型上进行实例化，从而实现了类型的通用性和复用。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
        <tag>类型表示</tag>
        <tag>T</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 实现药物剂量计算器的逻辑功能</title>
    <url>/2023/04/23/%E7%94%A8%20Python%20%E5%AE%9E%E7%8E%B0%E8%8D%AF%E7%89%A9%E5%89%82%E9%87%8F%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>时间：2023-04-22<br>标签： #Python #药物剂量计算器 #逻辑功能 #Tkinter #GUI </p>
<hr>
<p>在上一篇博客中，我们介绍了如何使用 Tkinter 构建药物剂量计算器的用户界面。本篇博客将介绍如何实现药物剂量计算器的逻辑功能，以便根据用户提供的患者信息计算药物剂量。</p>
<p><strong>1. 准备工作</strong></p>
<p>假设我们已经创建了用户界面，并为所有组件定义了变量。在继续之前，请确保已正确导入所需的库。</p>
<p><strong>2. 定义计算药物剂量的函数</strong></p>
<p>我们首先需要定义一个函数，该函数将根据年龄、体重、怀孕状态和过敏状态计算药物剂量。为简单起见，我们将使用以下简化公式：</p>
<ul>
<li>如果过敏，则药物剂量为 0。</li>
<li>对于非怀孕患者，药物剂量为体重 * 10。</li>
<li>对于怀孕患者，药物剂量为体重 * 5。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_dosage</span>(<span class="params">age, weight, pregnant, allergy</span>):</span></span><br><span class="line">    <span class="keyword">if</span> allergy == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> pregnant == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> weight * <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> weight * <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 获取用户输入</strong></p>
<p>我们需要从用户界面获取年龄、体重、怀孕状态和过敏状态的值。这可以通过获取每个组件的值来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">int</span>(age_spinbox.get())</span><br><span class="line">weight = <span class="built_in">float</span>(weight_spinbox.get())</span><br><span class="line">pregnant = pregnant_var.get()</span><br><span class="line">allergy = allergy_var.get()</span><br></pre></td></tr></table></figure>

<p><strong>4. 连接计算函数和用户界面</strong></p>
<p>现在我们已经定义了计算药物剂量的函数并获取了用户输入，我们需要将这些信息连接起来。首先，定义一个新的函数，该函数将获取用户输入，调用 <code>calculate_dosage()</code> 函数，并将结果显示在用户界面上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_submit</span>():</span></span><br><span class="line">    age = <span class="built_in">int</span>(age_spinbox.get())</span><br><span class="line">    weight = <span class="built_in">float</span>(weight_spinbox.get())</span><br><span class="line">    pregnant = pregnant_var.get()</span><br><span class="line">    allergy = allergy_var.get()</span><br><span class="line"></span><br><span class="line">    dosage = calculate_dosage(age, weight, pregnant, allergy)</span><br><span class="line">    result_var.<span class="built_in">set</span>(<span class="string">f&quot;Recommended dosage: <span class="subst">&#123;dosage&#125;</span> mg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，将 <code>command</code> 属性设置为提交按钮的 <code>on_submit</code> 函数。这将在用户单击提交按钮时调用 <code>on_submit()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">submit_button.config(command=on_submit)</span><br></pre></td></tr></table></figure>

<p><strong>5. 完整示例</strong></p>
<p>将所有代码片段组合在一起，最终的药物剂量计算器应如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_dosage</span>(<span class="params">age, weight, pregnant, allergy</span>):</span></span><br><span class="line">    <span class="keyword">if</span> allergy == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> pregnant == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> weight * <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> weight * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_submit</span>():</span></span><br><span class="line">    age = <span class="built_in">int</span>(age_spinbox.get())</span><br><span class="line">    weight = <span class="built_in">float</span>(weight_spinbox.get())</span><br><span class="line">    pregnant = pregnant_var.get()</span><br><span class="line">    allergy = allergy_var.get()</span><br><span class="line"></span><br><span class="line">    dosage = calculate_dosage(age, weight, pregnant, allergy)</span><br><span class="line">    result_var.<span class="built_in">set</span>(<span class="string">f&quot;Recommended dosage: <span class="subst">&#123;dosage&#125;</span> mg&quot;</span>)</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line"></span><br><span class="line">age_label = tk.Label(root, text=<span class="string">&quot;Age:&quot;</span>)</span><br><span class="line">age_spinbox = ttk.Spinbox(root, from_=<span class="number">0</span>, to=<span class="number">120</span>, increment=<span class="number">1</span>, width=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">pregnant_label = tk.Label(root, text=<span class="string">&quot;Pregnant:&quot;</span>)</span><br><span class="line">pregnant_var = tk.StringVar()</span><br><span class="line">pregnant_yes = tk.Radiobutton(root, text=<span class="string">&quot;Yes&quot;</span>, variable=pregnant_var, value=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">pregnant_no = tk.Radiobutton(root, text=<span class="string">&quot;No&quot;</span>, variable=pregnant_var, value=<span class="string">&quot;N&quot;</span>)</span><br><span class="line"></span><br><span class="line">allergy_label = tk.Label(root, text=<span class="string">&quot;Allergy:&quot;</span>)</span><br><span class="line">allergy_var = tk.StringVar()</span><br><span class="line">allergy_yes = tk.Radiobutton(root, text=<span class="string">&quot;Yes&quot;</span>, variable=allergy_var, value=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">allergy_no = tk.Radiobutton(root, text=<span class="string">&quot;No&quot;</span>, variable=allergy_var, value=<span class="string">&quot;N&quot;</span>)</span><br><span class="line"></span><br><span class="line">weight_label = tk.Label(root, text=<span class="string">&quot;Weight (kg):&quot;</span>)</span><br><span class="line">weight_spinbox = ttk.Spinbox(root, from_=<span class="number">0</span>, to=<span class="number">300</span>, increment=<span class="number">0.5</span>, width=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">submit_button = tk.Button(root, text=<span class="string">&quot;Calculate&quot;</span>, command=on_submit)</span><br><span class="line"></span><br><span class="line">result_label = tk.Label(root, text=<span class="string">&quot;Result:&quot;</span>)</span><br><span class="line">result_var = tk.StringVar()</span><br><span class="line">result_value = tk.Label(root, textvariable=result_var)</span><br><span class="line"></span><br><span class="line">age_label.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, padx=<span class="number">20</span>, pady=<span class="number">10</span>)</span><br><span class="line">age_spinbox.grid(row=<span class="number">0</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pregnant_label.grid(row=<span class="number">1</span>, column=<span class="number">0</span>)</span><br><span class="line">pregnant_yes.grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line">pregnant_no.grid(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">allergy_label.grid(row=<span class="number">2</span>, column=<span class="number">0</span>)</span><br><span class="line">allergy_yes.grid(row=<span class="number">2</span>, column=<span class="number">1</span>)</span><br><span class="line">allergy_no.grid(row=<span class="number">2</span>, column=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">weight_label.grid(row=<span class="number">3</span>, column=<span class="number">0</span>)</span><br><span class="line">weight_spinbox.grid(row=<span class="number">3</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">submit_button.grid(row=<span class="number">4</span>, column=<span class="number">0</span>, pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">result_label.grid(row=<span class="number">5</span>, column=<span class="number">0</span>)</span><br><span class="line">result_value.grid(row=<span class="number">5</span>, column=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<p>此代码将创建一个药物剂量计算器，用户可以输入年龄、体重、怀孕状态和过敏状态，然后单击“计算”按钮以获取推荐的药物剂量。该剂量将显示在界面的“结果”部分。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Tkinter</tag>
        <tag>GUI</tag>
        <tag>药物剂量计算器</tag>
        <tag>逻辑功能</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解StringBuffer</title>
    <url>/2023/04/28/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3StringBuffer/</url>
    <content><![CDATA[<p>时间：2023-04-24<br>标签： #Java #StringBuffer #StringBuilder #String #MutableStrings #JavaStringBuffer</p>
<hr>
<p>在 Java 编程语言中，字符串处理是一个常见的任务。Java 提供了多种处理字符串的类，如 <code>String</code>, <code>StringBuffer</code>, 和 <code>StringBuilder</code>。本篇博客将重点介绍 <code>StringBuffer</code> 类及其使用。</p>
<h2 id="什么是-StringBuffer？"><a href="#什么是-StringBuffer？" class="headerlink" title="什么是 StringBuffer？"></a>什么是 StringBuffer？</h2><p><code>StringBuffer</code> 是一个可变字符串类，用于处理可修改的字符串。与 <code>String</code> 类不同，<code>StringBuffer</code> 允许在原地修改字符串内容，而不是创建新的字符串对象。这在某些场景下，特别是需要频繁修改字符串内容的情况下，可以大大提高性能。</p>
<h2 id="StringBuffer-与-String-的区别"><a href="#StringBuffer-与-String-的区别" class="headerlink" title="StringBuffer 与 String 的区别"></a>StringBuffer 与 String 的区别</h2><ol>
<li><p>可变性：<code>String</code> 是不可变的，一旦创建，无法修改。而 <code>StringBuffer</code> 是可变的，可以在原地修改内容。</p>
</li>
<li><p>性能：当涉及到频繁的字符串修改操作时，<code>StringBuffer</code> 通常比 <code>String</code> 具有更好的性能，因为它避免了创建大量的临时字符串对象。</p>
</li>
<li><p>线程安全：<code>StringBuffer</code> 是线程安全的，因为它的大部分方法都是同步的（synchronized）。而 <code>String</code> 和 <code>StringBuilder</code> 不是线程安全的。</p>
</li>
</ol>
<h2 id="StringBuffer-与-StringBuilder-的区别"><a href="#StringBuffer-与-StringBuilder-的区别" class="headerlink" title="StringBuffer 与 StringBuilder 的区别"></a>StringBuffer 与 StringBuilder 的区别</h2><p>虽然 <code>StringBuffer</code> 和 <code>StringBuilder</code> 都是可变字符串类，但它们之间存在一个关键区别：线程安全性。<code>StringBuffer</code> 是线程安全的，而 <code>StringBuilder</code> 不是。这意味着在多线程环境下，如果需要修改字符串，优先使用 <code>StringBuffer</code>。然而，如果线程安全不是关注点，<code>StringBuilder</code> 通常具有更好的性能，因为它没有同步开销。</p>
<h2 id="如何使用-StringBuffer？"><a href="#如何使用-StringBuffer？" class="headerlink" title="如何使用 StringBuffer？"></a>如何使用 StringBuffer？</h2><p>以下是一些使用 <code>StringBuffer</code> 的示例：</p>
<h3 id="创建-StringBuffer-对象"><a href="#创建-StringBuffer-对象" class="headerlink" title="创建 StringBuffer 对象"></a>创建 StringBuffer 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(); <span class="comment">// 创建一个空的 StringBuffer 对象</span></span><br><span class="line">StringBuffer buffer2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello, World!&quot;</span>); <span class="comment">// 用指定的字符串创建一个 StringBuffer 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="添加和修改字符串内容"><a href="#添加和修改字符串内容" class="headerlink" title="添加和修改字符串内容"></a>添加和修改字符串内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.append(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 追加字符串</span></span><br><span class="line">buffer.append(<span class="string">&quot;World!&quot;</span>); <span class="comment">// 追加字符串</span></span><br><span class="line">buffer.insert(<span class="number">0</span>, <span class="string">&quot;Welcome! &quot;</span>); <span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">buffer.replace(<span class="number">0</span>, <span class="number">8</span>, <span class="string">&quot;Greetings&quot;</span>); <span class="comment">// 替换指定范围的字符串</span></span><br><span class="line">buffer.delete(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 删除指定范围的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = buffer.length(); <span class="comment">// 获取字符串长度</span></span><br><span class="line"><span class="keyword">char</span> c = buffer.charAt(<span class="number">0</span>); <span class="comment">// 获取指定位置的字符</span></span><br><span class="line">String str = buffer.toString(); <span class="comment">// 将 StringBuffer 转换为 String</span></span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>StringBuffer</code> 是一个非常实用的类，尤其是在处理需要频繁修改的字符串时。它提供了线程安全的字符串操作，使得在多线程环境中也可以放心使用。然而，在单线程或不需要线程</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
        <tag>StringBuilder</tag>
        <tag>StringBuffer</tag>
        <tag>MutableStrings</tag>
        <tag>JavaStringBuffer</tag>
      </tags>
  </entry>
  <entry>
    <title>纯函数式语言与并行编程</title>
    <url>/2023/04/28/%E7%BA%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #纯函数式语言 #并行编程 #无副作用 #内存争用</p>
<hr>
<p>纯函数式编程是一种编程范式，其中函数具有以下特点：</p>
<ol>
<li>无副作用：函数不会修改任何外部状态。这意味着函数的输出完全取决于其输入，而与其他外部变量无关。</li>
<li>引用透明：给定相同的输入，函数总是产生相同的输出。</li>
</ol>
<p>纯函数式语言的一个重要优势是，它们在并行编程中表现出色。以下是纯函数式语言如何解决并行编程问题的详细说明：</p>
<ol>
<li>无内存争用：由于纯函数不会修改现有值，而是生成新值，因此不会导致内存争用。内存争用是指多个线程试图同时访问和修改共享数据，导致数据不一致的情况。在纯函数式编程中，由于没有共享数据被修改，因此不存在内存争用问题。</li>
</ol>
<p>例如，考虑一个简单的加法操作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">add</span> x y = x + y</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>add</code> 函数是纯函数，它不修改任何外部状态。因此，多个线程可以并行调用这个函数，而不用担心内存争用。</p>
<ol start="2">
<li><p>易于推理：纯函数使代码更容易理解，因为函数的行为完全取决于其输入。这使得开发人员能够更容易地推理代码的行为，从而更容易地在并行环境中编写和调试代码。</p>
</li>
<li><p>并行性能优化：纯函数式编程语言的编译器可以自动识别并行计算的潜在机会。这使得编译器可以自动执行优化，如任务分解和负载平衡，从而提高并行执行的性能。</p>
</li>
</ol>
<p>总之，纯函数式编程语言提供了一种简化并行编程的方法，因为它们不会产生内存争用，并且易于推理。虽然纯函数式编程并非唯一解决并行编程问题的方法，但它是一种非常有效且易于实现的方法。</p>
]]></content>
      <tags>
        <tag>纯函数式语言</tag>
        <tag>并行编程</tag>
        <tag>无副作用</tag>
        <tag>内存争用</tag>
      </tags>
  </entry>
  <entry>
    <title>自修改代码的问题</title>
    <url>/2023/04/28/%E8%87%AA%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #自修改代码 #可读性 #测试难度</p>
<hr>
<p>自修改代码指的是在运行时修改自身的程序。这种代码通常以某种方式动态生成或更改其执行过程中的指令。尽管自修改代码在某些情况下可能具有一定的优势（例如，性能优化），但它也带来了许多问题，使得其在现代编程实践中的应用相对较少。以下是使用纯粹的自修改代码的一些问题：</p>
<ol>
<li><p>可读性差：自修改代码通常很难理解，因为它的行为在程序运行时是动态变化的。这使得我们很难确定程序在做什么，导致代码难以阅读和维护。</p>
</li>
<li><p>测试难度大：由于自修改代码的动态特性，测试变得非常复杂。要全面测试这样的代码，我们需要测试其在各种可能的执行状态下的行为。这可能涉及代码转换、修改等过程，使得测试过程变得繁琐且容易出错。</p>
</li>
<li><p>可维护性差：自修改代码的可维护性较差，因为在调试和修复过程中很难确定哪部分代码可能导致问题。此外，对自修改代码的更改可能会产生意想不到的副作用，从而导致更多的问题。</p>
</li>
<li><p>可移植性差：自修改代码可能依赖于底层系统的特定实现，使得它在不同的环境中运行时出现问题。这限制了代码的可移植性和应用范围。</p>
</li>
</ol>
<p>综上所述，纯粹的自修改代码在很多方面都具有不足，特别是在可读性、测试难度、可维护性和可移植性方面。在现代编程实践中，通常更倾向于使用更具可读性、可维护性的设计模式和架构，以降低软件开发和维护的复杂性。</p>
]]></content>
      <tags>
        <tag>自修改代码</tag>
        <tag>可读性</tag>
        <tag>测试难度</tag>
      </tags>
  </entry>
  <entry>
    <title>被 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的</title>
    <url>/2023/04/28/%E8%A2%AB%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E6%98%AF%20final%20%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E5%90%8C%20final%20%E6%95%88%E6%9E%9C%E7%9A%84/</url>
    <content><![CDATA[<p>时间：2023-04-26<br>标签： #Java #Lambda #Final #EffectivelyFinal</p>
<hr>
<p>确实，被 Lambda 表达式引用的局部变量必须是 final 或者是等同 final 效果的，这也被称为“effectively final”。</p>
<ol>
<li><p>为什么局部变量必须是 final 或者 effectively final：</p>
<ul>
<li>Lambda 表达式会创建一个匿名类的实例，这个实例可能在另一个线程中执行。为了避免数据不一致的问题，Lambda 表达式要求局部变量是 final 或者 effectively final。</li>
<li>Final 变量的值是不可改变的，这就避免了在多线程环境下的数据竞争和同步问题。</li>
<li>对于 effectively final 变量，虽然它们没有显式地被声明为 final，但在实际使用过程中，它们的值没有被改变，所以它们也被视为不可变的。</li>
</ul>
</li>
<li><p>什么是 effectively final：</p>
<ul>
<li>当一个局部变量满足以下条件时，它被认为是 effectively final：<ol>
<li>变量没有被显式地声明为 final。</li>
<li>在初始化之后，变量的值没有被改变。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>总结：在 Java 中，被 Lambda 表达式引用的局部变量必须是 final 或者 effectively final。这是为了避免在多线程环境下的数据竞争和同步问题。Effectively final 指的是变量在实际使用过程中，它们的值没有被改变，所以它们也被视为不可变的。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
        <tag>Final</tag>
        <tag>EffectivelyFinal</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器为轻量级对象的优势及约束条件</title>
    <url>/2023/04/28/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #迭代器 #轻量级对象 #优势 #约束条件</p>
<hr>
<p>迭代器（Iterator）是一种设计模式，用于在不暴露集合内部结构的情况下，访问一个聚合对象的各个元素。以下是对上述内容的逻辑关系解释：</p>
<ol>
<li><p>轻量级对象的定义：</p>
<ul>
<li>轻量级对象（Lightweight Object）指的是创建和使用该对象所需资源较少的对象。相对于重量级对象，轻量级对象具有较小的内存占用和较低的性能开销。</li>
</ul>
</li>
<li><p>迭代器作为轻量级对象的优势：</p>
<ul>
<li>创建代价小：由于迭代器是轻量级对象，创建它所需的资源较少。这使得在需要频繁创建和销毁迭代器的场景中，性能开销较小。</li>
<li>访问集合元素：迭代器提供了统一的接口，方便地遍历不同类型的集合，而无需暴露集合内部结构。这有助于实现代码的解耦和复用。</li>
</ul>
</li>
<li><p>迭代器的奇怪约束：</p>
<ul>
<li>由于迭代器的轻量级特性，有时它们的实现会受到一定的约束。例如，为了减小内存占用，迭代器可能无法保存遍历过程中的完整状态信息。在这种情况下，可能需要遵循一定的使用约定，如：避免在遍历过程中修改集合、确保多个迭代器之间互不干扰等。</li>
</ul>
</li>
</ol>
<p>综上所述，迭代器作为轻量级对象，具有创建代价小、方便访问集合元素的优势，但在实现上可能受到一些约束。在实际使用中，需要注意遵循相应的约定，以确保迭代器的正确性能和功能表现。</p>
]]></content>
      <tags>
        <tag>迭代器</tag>
        <tag>轻量级对象</tag>
        <tag>优势</tag>
        <tag>约束条件</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2023/04/28/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>面向对象编程（OOP）与内存争用</title>
    <url>/2023/04/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%89%E7%94%A8/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #面向对象编程 #内存争用 #共享状态</p>
<hr>
<p>面向对象编程（OOP）是一种编程范式，其核心概念包括类、对象和继承。在 OOP 中，程序被组织为对象，这些对象具有数据（属性）和操作数据的方法。由于 OOP 允许在对象之间共享状态，因此在多线程环境中可能会导致内存争用。</p>
<p>以下是为什么 OOP 语言可能会产生内存争用的原因：</p>
<ol>
<li>共享状态：OOP 语言通常允许对象之间共享状态。当多个线程访问和修改相同的对象或数据时，可能会导致数据不一致或不可预测的行为。例如，两个线程同时访问并修改同一个对象的属性可能会导致意外的结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Counter</code> 类有一个 <code>count</code> 属性和一个 <code>increment</code> 方法。如果多个线程同时访问和修改 <code>count</code> 属性，它们可能会争用这个共享状态，导致数据不一致。</p>
<ol start="2">
<li>非原子操作：在 OOP 语言中，对共享状态的修改可能不是原子的。非原子操作是指在执行过程中可能被其他操作中断的操作。当多个线程在非原子操作上争用时，可能会导致不正确的结果。</li>
</ol>
<p>在上面的 <code>Counter</code> 示例中，<code>increment</code> 方法是非原子的，因为它包含读取、修改和写入 <code>count</code> 属性的三个操作。在多线程环境中，这可能导致丢失更新或不一致的状态。</p>
<p>要解决 OOP 语言中的内存争用问题，开发人员通常需要使用同步机制（如互斥锁、信号量等）来保护共享状态。这些同步机制可以确保在同一时间只有一个线程可以访问和修改共享数据，从而防止内存争用。然而，同步也可能导致性能下降和死锁等问题，因此在实践中需要谨慎使用。</p>
]]></content>
      <tags>
        <tag>内存争用</tag>
        <tag>面向对象编程</tag>
        <tag>共享状态</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器为轻量级对象的原因</title>
    <url>/2023/04/28/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%BA%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>时间：2023-04-27<br>标签： #迭代器 #轻量级对象 #创建代价</p>
<hr>
<p>迭代器被视为轻量级对象，主要原因在于其设计和实现上的简洁性。以下是为什么迭代器是轻量级对象，创建代价小的解释：</p>
<ol>
<li><p>简单的数据结构：</p>
<ul>
<li>迭代器通常使用简单的数据结构来实现，如指针或者索引。这些数据结构在内存占用和性能开销方面相对较小。</li>
</ul>
</li>
<li><p>有限的状态信息：</p>
<ul>
<li>迭代器主要负责记录当前遍历的位置和状态，不需要存储集合本身的数据。因此，迭代器内部维护的状态信息相对较少，降低了内存占用。</li>
</ul>
</li>
<li><p>精简的方法实现：</p>
<ul>
<li>迭代器的方法通常相对简单，例如 next ()、hasNext ()等。这些方法的实现较为直接，不涉及复杂的计算和逻辑，从而降低了性能开销。</li>
</ul>
</li>
<li><p>无需复制集合数据：</p>
<ul>
<li>迭代器只需引用原始集合，而无需复制集合数据。这减少了内存占用和创建代价。</li>
</ul>
</li>
</ol>
<p>综上所述，迭代器之所以被认为是轻量级对象，主要是因为其简单的数据结构、有限的状态信息、精简的方法实现以及无需复制集合数据等特点。这些特点使得迭代器在创建和使用过程中具有较低的内存占用和性能开销。</p>
]]></content>
      <tags>
        <tag>迭代器</tag>
        <tag>轻量级对象</tag>
        <tag>创建代价</tag>
      </tags>
  </entry>
</search>
